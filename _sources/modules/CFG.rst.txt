=====================
CFG Practice Problems
=====================

.. contents::
   :local:
   :depth: 2

----

.. raw:: html

   <style>
     /* === General Typography and Layout === */
     body {
       font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
       line-height: 1.6;
     }
     h2, h3, h4 {
       color: #7b1113; /* Stanford Maroon */
       font-weight: 600;
       margin-top: 1.8em;
       margin-bottom: 0.6em;
       text-align: left;
     }
     code, .code {
       background-color: #f7f7f7;
       padding: 2px 5px;
       border-radius: 4px;
     }
     p, li {
       font-size: 16px;
     }

     /* === Collapsible Solution Blocks === */
     details {
       background-color: #fcfcfc;
       border: 1px solid #ddd;
       border-radius: 8px;
       padding: 10px 15px;
       margin: 12px 0;
       box-shadow: 0 1px 2px rgba(0,0,0,0.05);
     }
     summary {
       font-weight: 600;
       font-size: 17px;
       color: #444;
       cursor: pointer;
       padding: 5px 0;
     }
     details[open] summary {
       color: #7b1113;
     }

     /* === Admonitions (Hints, Tips) === */
     .admonition.tip, .admonition.hint {
       border-left: 4px solid #7b1113 !important;
       background-color: #f9f9f9 !important;
     }

     /* === Mobile Optimization === */
     @media (max-width: 600px) {
       p, li {
         font-size: 15px;
         line-height: 1.5;
       }
       h2, h3, h4 {
         font-size: 20px;
       }
       summary {
         font-size: 16px;
       }
     }
   </style>

----

Level 1: Basic Grammar Construction
====================================

**Question 01:** Construct a CFG for all strings of length 2 over :math:`\Sigma = \{a, b\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí XX
   X ‚Üí a | b

**Derivation for "ab":**

.. code-block:: text

   S
   ‚üπ XX
   ‚üπ aX
   ‚üπ ab ‚úì

.. graphviz::

   digraph G {
      rankdir=TB;
      node [shape=circle, style=filled, fillcolor="#f9f9f9"];
      S -> X1 [label=" "];
      S -> X2 [label=" "];
      X1 -> a;
      X2 -> b;
      {rank=same; X1; X2;}
   }

**Valid strings:** `aa`, `ab`, `ba`, `bb`

.. admonition:: Concept Insight
   :class: tip

   Each X can independently produce 'a' or 'b', giving us 2 √ó 2 = 4 total combinations.

.. raw:: html

   </details>

----

**Question 02:** Construct a CFG for :math:`L = \{a^n b^n \mid n \geq 1\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí aSb | ab

**Derivation for "aaabbb":**

.. code-block:: text

   S
   ‚üπ aSb
   ‚üπ a(aSb)b
   ‚üπ a(a(aSb)b)b
   ‚üπ a(a(ab)b)b
   ‚üπ aaabbb ‚úì

.. graphviz::

   digraph G {
      rankdir=TB;
      node [shape=circle, style=filled, fillcolor="#f9f9f9"];
      S1 [label="S"];
      S1 -> a1;
      S1 -> S2 [label="S"];
      S1 -> b1;
      S2 -> a2;
      S2 -> S3 [label="S"];
      S2 -> b2;
      S3 -> a3;
      S3 -> b3;
   }

.. admonition:: Concept Insight
   :class: tip

   Each recursive step adds one 'a' at the left and one 'b' at the right, maintaining equality.
   The base case `S ‚Üí ab` ensures at least one of each symbol.

.. raw:: html

   </details>

----

**Question 03:** Construct a CFG for :math:`L = \{a^n b^m \mid n, m \geq 1\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí AB
   A ‚Üí aA | a
   B ‚Üí bB | b

**Derivation for "aaabb":**

.. code-block:: text

   S
   ‚üπ AB
   ‚üπ (aA)B
   ‚üπ (a(aA))B
   ‚üπ (a(a(a)))B
   ‚üπ aaaB
   ‚üπ aaa(bB)
   ‚üπ aaa(b(bB))
   ‚üπ aaa(b(b(b)))
   ‚üπ aaabbb ‚úì

.. admonition:: Concept Insight
   :class: tip

   Variables A and B are **independent**: A generates any number of a's, 
   B generates any number of b's. Their concatenation gives the language.

.. raw:: html

   </details>

----

**Question 04:** Construct a CFG for all **even-length palindromes** over :math:`\{a, b\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí aSa | bSb | Œµ

**Derivation for "abba":**

.. code-block:: text

   S
   ‚üπ aSa
   ‚üπ a(bSb)a
   ‚üπ a(bŒµb)a
   ‚üπ a(bb)a
   ‚üπ abba ‚úì

.. graphviz::

   digraph G {
      rankdir=TB;
      node [shape=circle, style=filled, fillcolor="#f9f9f9"];
      S1 [label="S"];
      S1 -> a1 [label="a"];
      S1 -> S2 [label="S"];
      S1 -> a2 [label="a"];
      S2 -> b1 [label="b"];
      S2 -> eps [label="Œµ"];
      S2 -> b2 [label="b"];
      eps [label="Œµ", shape=plaintext];
      {rank=same; a1; S2; a2;}
      {rank=same; b1; eps; b2;}
   }

.. admonition:: Visual Tip
   :class: hint

   The grammar builds palindromes from the **center outward**, ensuring symmetry.
   The base case Œµ gives even-length strings.

.. raw:: html

   </details>

----

**Question 05:** Construct a CFG for all **palindromes** (odd and even) over :math:`\{a, b\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí aSa | bSb | a | b | Œµ

**Example strings:** `aba`, `abba`, `a`, `b`, `Œµ`

**Derivation for "aba":**

.. code-block:: text

   S
   ‚üπ aSa
   ‚üπ a(b)a
   ‚üπ aba ‚úì

.. admonition:: Concept Insight
   :class: tip

   Unlike even-length palindromes, we need base cases for **single characters** (a, b)
   to handle odd-length palindromes like "aba" or "bab".

.. raw:: html

   </details>

----

Level 2: Position-Based Patterns
=================================

**Question 06:** Construct a CFG for strings **starting with 'a'** and **ending with 'b'** over :math:`\{a, b\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí aXb | ab
   X ‚Üí aX | bX | Œµ

**Derivation for "aabbb":**

.. code-block:: text

   S
   ‚üπ aXb
   ‚üπ a(aX)b
   ‚üπ a(a(bX))b
   ‚üπ a(a(b(bX)))b
   ‚üπ a(a(b(bŒµ)))b
   ‚üπ aabbb ‚úì

.. admonition:: Visual Tip
   :class: hint

   Fix the first and last positions, then fill the middle with any string (including empty).

.. raw:: html

   </details>

----

**Question 07:** Construct a CFG for strings **starting and ending with different symbols** over :math:`\{a, b\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí aXb | bXa
   X ‚Üí aX | bX | Œµ

**Example strings:** `ab`, `ba`, `aab`, `bba`, `abba`

**Derivation for "aab":**

.. code-block:: text

   S
   ‚üπ aXb
   ‚üπ a(aX)b
   ‚üπ a(aŒµ)b
   ‚üπ aab ‚úì

.. admonition:: Concept Insight
   :class: tip

   Two cases: (1) starts with 'a', ends with 'b', or (2) starts with 'b', ends with 'a'.
   The union is expressed by the two productions for S.

.. raw:: html

   </details>

----

**Question 08:** Construct a CFG for strings **starting and ending with the same symbol** over :math:`\{a, b\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí aXa | bXb | a | b | Œµ
   X ‚Üí aX | bX | Œµ

**Example strings:** `a`, `b`, `aa`, `bb`, `aba`, `bab`, `Œµ`

**Derivation for "aba":**

.. code-block:: text

   S
   ‚üπ aXa
   ‚üπ a(bX)a
   ‚üπ a(bŒµ)a
   ‚üπ aba ‚úì

.. admonition:: Concept Insight
   :class: tip

   Need to handle: (1) length ‚â•2 with same start/end, (2) single characters, (3) empty string.

.. raw:: html

   </details>

----

Level 3: Multiple Variable Dependencies
========================================

**Question 09:** Construct a CFG for :math:`L = \{a^n b^m c^m \mid n, m \geq 1\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí AS'
   A ‚Üí aA | a
   S' ‚Üí bS'c | bc

**Derivation for "aabbcc":**

.. code-block:: text

   S
   ‚üπ AS'
   ‚üπ (aA)S'
   ‚üπ (a(a))S'
   ‚üπ aaS'
   ‚üπ aa(bS'c)
   ‚üπ aa(b(bc)c)
   ‚üπ aabbcc ‚úì

.. graphviz::

   digraph G {
      rankdir=TB;
      node [shape=circle, style=filled, fillcolor="#f9f9f9"];
      S -> A;
      S -> Sp [label="S'"];
      A -> a1;
      A -> a2;
      Sp -> b1;
      Sp -> Sp2 [label="S'"];
      Sp -> c1;
      Sp2 -> b2;
      Sp2 -> c2;
   }

.. admonition:: Concept Insight
   :class: tip

   The count of 'a's is **independent** of b's and c's. 
   Variable A handles a's freely, while S' enforces b^m c^m equality.

.. raw:: html

   </details>

----

**Question 10:** Construct a CFG for :math:`L = \{a^n b^m c^n \mid n, m \geq 1\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí aSc | B
   B ‚Üí bB | b

**Derivation for "aabcc":**

.. code-block:: text

   S
   ‚üπ aSc
   ‚üπ a(aSc)c
   ‚üπ a(B)c
   ‚üπ a(bB)c
   ‚üπ a(bb)c
   ‚üπ aabbcc ‚úì

.. admonition:: Concept Insight
   :class: tip

   Here 'a' and 'c' must match (outer dependency), while 'b' count is independent (middle).
   S handles the a-c matching, B generates independent b's.

.. raw:: html

   </details>

----

**Question 11:** Construct a CFG for :math:`L = \{a^n b^n c^m d^m \mid n, m \geq 1\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí XY
   X ‚Üí aXb | ab
   Y ‚Üí cYd | cd

**Derivation for "aabbccdd":**

.. code-block:: text

   S
   ‚üπ XY
   ‚üπ (aXb)Y
   ‚üπ (a(ab)b)Y
   ‚üπ (aabb)Y
   ‚üπ aabb(cYd)
   ‚üπ aabb(c(cd)d)
   ‚üπ aabbccdd ‚úì

.. admonition:: Concept Insight
   :class: tip

   Two **independent** equal-count pairs in sequence.
   X handles first pair (a^n b^n), Y handles second pair (c^m d^m).

.. raw:: html

   </details>

----

**Question 12:** Construct a CFG for :math:`L = \{a^i b^j c^k \mid i = j \text{ or } j = k\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí A | B
   A ‚Üí CD
   C ‚Üí aCb | ab
   D ‚Üí cD | c
   B ‚Üí EF
   E ‚Üí aE | a
   F ‚Üí bFc | bc

**Example strings:** 
- `aabbcc` (i=j=2)
- `aaabcc` (j=k=2)

.. admonition:: Concept Insight
   :class: tip

   This is a **union** of two languages: L‚ÇÅ where i=j (any k), and L‚ÇÇ where j=k (any i).
   Non-deterministically choose which equality to enforce.

.. raw:: html

   </details>

----

Level 4: Advanced Patterns
===========================

**Question 13:** Construct a CFG for strings with **equal number of a's and b's** over :math:`\{a, b\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí SS | aSb | bSa | Œµ

**Example strings:** `ab`, `ba`, `aabb`, `abab`, `baab`

**Derivation for "abab":**

.. code-block:: text

   S
   ‚üπ SS
   ‚üπ (aSb)S
   ‚üπ (ab)S
   ‚üπ (ab)(aSb)
   ‚üπ (ab)(ab)
   ‚üπ abab ‚úì

.. admonition:: Visual Tip
   :class: hint

   Unlike a^n b^n, here a's and b's can be **interleaved** in any order.
   SS allows concatenation, aSb and bSa allow nesting/pairing.

.. raw:: html

   </details>

----

**Question 14:** Construct a CFG for :math:`L = \{a^n b^m \mid n > m, n,m \geq 1\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí AB
   A ‚Üí aAb | aA | a
   B ‚Üí aB | Œµ

**Key idea:** A ensures at least one extra 'a', B adds more a's if needed.

**Derivation for "aaab":**

.. code-block:: text

   S
   ‚üπ AB
   ‚üπ (aA)B
   ‚üπ (a(aAb))B
   ‚üπ (a(a(a)))B
   ‚üπ (aaab)Œµ
   ‚üπ aaab ‚úì

.. admonition:: Concept Insight
   :class: tip

   To ensure n > m: match m pairs (a,b), then ensure at least one extra 'a' remains.

.. raw:: html

   </details>

----

**Question 15:** Construct a CFG for :math:`L = \{a^n b^m \mid n \neq m\}`.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S ‚Üí A | B
   A ‚Üí (grammar for n > m from Q14)
   B ‚Üí (grammar for n < m - symmetric)

**Example strings:** `aab`, `abb`, `aaab`, `abbb`

.. admonition:: Concept Insight
   :class: tip

   Union of two cases: (1) more a's than b's, (2) more b's than a's.

.. raw:: html

   </details>

----

Level 5: FA to CFG Conversion
==============================

**Question 16:** Convert the following FA to CFG.

**FA Description:**

- States: {q‚ÇÄ (start, final), q‚ÇÅ}
- Alphabet: {a, b}
- Transitions: q‚ÇÄ ‚Üí·µÉ q‚ÇÅ, q‚ÇÅ ‚Üí·µá q‚ÇÄ

.. graphviz::

   digraph FA {
      rankdir=LR;
      node [shape=circle, style=filled, fillcolor="#f9f9f9"];
      q0 [label="q‚ÇÄ\n(Start,Final)", shape=doublecircle];
      q1 [label="q‚ÇÅ"];
      q0 -> q1 [label="a"];
      q1 -> q0 [label="b"];
   }

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S‚ÇÄ ‚Üí aS‚ÇÅ | Œµ
   S‚ÇÅ ‚Üí bS‚ÇÄ

**Derivation for "abab":**

.. code-block:: text

   S‚ÇÄ
   ‚üπ aS‚ÇÅ
   ‚üπ a(bS‚ÇÄ)
   ‚üπ ab(aS‚ÇÅ)
   ‚üπ ab(a(bS‚ÇÄ))
   ‚üπ abab(Œµ)
   ‚üπ abab ‚úì

.. admonition:: Concept Note
   :class: tip

   For each state q, create variable S·µ©. For transition (q, x, p), add S·µ© ‚Üí xS‚Çö.
   Final states get Œµ-productions.

.. raw:: html

   </details>

----

**Question 17:** Convert FA accepting strings ending with "ab" to CFG.

.. graphviz::

   digraph FA {
      rankdir=LR;
      node [shape=circle, style=filled, fillcolor="#f9f9f9"];
      q0 [label="q‚ÇÄ\n(Start)"];
      q1 [label="q‚ÇÅ"];
      q2 [label="q‚ÇÇ\n(Final)", shape=doublecircle];
      q0 -> q0 [label="a,b"];
      q0 -> q1 [label="a"];
      q1 -> q2 [label="b"];
      q2 -> q0 [label="a,b"];
   }

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. code-block:: text

   S‚ÇÄ ‚Üí aS‚ÇÄ | bS‚ÇÄ | aS‚ÇÅ
   S‚ÇÅ ‚Üí bS‚ÇÇ
   S‚ÇÇ ‚Üí aS‚ÇÄ | bS‚ÇÄ | Œµ

**Example:** `aaab`, `bab`, `ab`

.. admonition:: Visual Tip
   :class: hint

   The path must eventually reach q‚ÇÅ then q‚ÇÇ via 'a' then 'b' to accept.

.. raw:: html

   </details>

----

Level 6: Chomsky Normal Form (CNF)
===================================

**Question 18:** Find maximum yield length for CNF grammar:

.. code-block:: text

   S ‚Üí AB
   A ‚Üí a
   B ‚Üí b

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. graphviz::

   digraph CFG {
       rankdir=TB;
       node [shape=circle, style=filled, fillcolor="#f9f9f9"];
       S -> A;
       S -> B;
       A -> a;
       B -> b;
   }

**Derivation Tree for "ab":**

- Longest path length = 2 = k
- Maximum yield length = 2^(k-1) = 2^1 = 2

.. admonition:: Concept Insight
   :class: tip

   In CNF, each production is either A ‚Üí BC or A ‚Üí a.
   The maximum yield length formula is 2^(k-1) where k is the tree height.

.. raw:: html

   </details>

----

**Question 19:** Find maximum yield length for:

.. code-block:: text

   S ‚Üí AB
   A ‚Üí EF
   B ‚Üí C
   E ‚Üí a
   F ‚Üí b
   C ‚Üí c

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. graphviz::

   digraph CFG {
       rankdir=TB;
       node [shape=circle, style=filled, fillcolor="#f9f9f9"];
       S -> A;
       S -> B;
       A -> E;
       A -> F;
       E -> a;
       F -> b;
       B -> C;
       C -> c;
   }

**Derivation for "abc":**

- Longest path = 3 = k
- Maximum yield = 2^(k-1) = 2^2 = 4

.. admonition:: Visual Tip
   :class: hint

   Each level in CNF can double the number of leaves (maximum branching = 2).

.. raw:: html

   </details>

----

Level 7: CYK Algorithm
======================

**Question 20:** Use CYK to check if "aab" belongs to:

.. code-block:: text

   S ‚Üí AB | BC
   A ‚Üí BA | a
   B ‚Üí CC | b
   C ‚Üí AB | a

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. admonition:: CYK Table for "aab"
   :class: quiz

   +--------+----------+----------+----------+
   | Length | Pos 1    | Pos 2    | Pos 3    |
   +========+==========+==========+==========+
   | 1      | {A, C}   | {A, C}   | {B}      |
   +--------+----------+----------+----------+
   | 2      | {B}      | {S, C}   | ‚Äî        |
   +--------+----------+----------+----------+
   | 3      | {B}      | ‚Äî        | ‚Äî        |
   +--------+----------+----------+----------+

**Step-by-step:**

1. **Length 1:** 
   - V‚ÇÅ,‚ÇÅ for 'a': {A, C} (from A‚Üía, C‚Üía)
   - V‚ÇÇ,‚ÇÅ for 'a': {A, C}
   - V‚ÇÉ,‚ÇÅ for 'b': {B} (from B‚Üíb)

2. **Length 2:**
   - V‚ÇÅ,‚ÇÇ for "aa": Check {A,C}√ó{A,C} = {AA, AC, CA, CC}
     ‚Üí B‚ÜíCC matches ‚Üí {B}
   - V‚ÇÇ,‚ÇÇ for "ab": Check {A,C}√ó{B} = {AB, CB}
     ‚Üí S‚ÜíAB, C‚ÜíAB match ‚Üí {S, C}

3. **Length 3:**
   - V‚ÇÅ,‚ÇÉ for "aab": 
     - Split k=1: {A,C}√ó{S,C} ‚Üí CC gives {B}
     - Split k=2: {B}√ó{B} ‚Üí no rule
   - Result: {B}

**Conclusion:** S ‚àâ V‚ÇÅ,‚ÇÉ ‚Üí "aab" is **REJECTED** ‚úó

.. admonition:: Insight
   :class: tip

   CYK builds bottom-up: fill length-1 cells first, then length-2, etc.
   String is accepted only if S appears in the top-left cell.

.. raw:: html

   </details>

----

Level 8: Language Classification
=================================

**Question 21 (MCQ):** Which language is NOT context-free?

A) :math:`\{a^n b^n \mid n \geq 0\}`

B) :math:`\{a^n b^n c^n \mid n \geq 0\}`

C) :math:`\{a^i b^j \mid i, j \geq 0\}`

D) :math:`\{ww^R \mid w \in \{a,b\}^*\}`

.. raw:: html

   <details>
   <summary><strong>‚úÖ ANSWER</strong></summary>

**Answer:** B) :math:`\{a^n b^n c^n\}` ‚úó

**Reason:**

- Requires THREE equal counts simultaneously
- PDA has only ONE stack
- Can handle at most TWO dependencies (like a^n b^n)
- This is a **Context-Sensitive Language** (CSL)

.. admonition:: Pumping Lemma Proof Sketch
   :class: tip

   Consider w = a^p b^p c^p. Any decomposition with |vxy| ‚â§ p means vxy spans
   at most 2 symbol types. Pumping breaks the three-way equality.

.. raw:: html

   </details>

----

**Question 22 (MCQ):** Which statement about CFGs is TRUE?

A) Every CFG can be converted to CNF

B) CNF has productions of form A ‚Üí BC or A ‚Üí a only

C) CFLs are closed under union and concatenation

D) All of the above

.. raw:: html

   <details>
   <summary><strong>‚úÖ ANSWER</strong></summary>

**Answer:** D) All of the above ‚úì

**Explanation:**

- **A:** True - any CFG can be normalized to CNF
- **B:** True - definition of CNF
- **C:** True - CFLs are closed under union, concatenation, and Kleene star

.. raw:: html

   </details>

----

**Question 23:** Prove that :math:`L = \{ww \mid w \in \{a,b\}^*\}` is NOT context-free.

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

.. admonition:: Proof
   :class: quiz

   **Why Copying Fails:**

   1. **The Challenge:** Need exact forward copy (not reverse)
   2. **Contrast with ww^R:** 
      - ww^R (palindrome): PDA can verify using stack (LIFO matches reverse)
      - ww (copy): Need to verify forward copy
   3. **PDA Limitation:**
      - LIFO structure can only compare in reverse order
      - Cannot "remember" first half AND compare in forward order
   4. **Pumping Lemma:**
      - Consider w = a^p b^p a^p b^p
      - Any pumping breaks the ww structure

**Conclusion:** Copying requires more power than a PDA provides.

.. admonition:: Key Insight
   :class: tip

   **ww^R is CFL** but **ww is NOT CFL**. The difference is comparison order!

.. raw:: html

   </details>

----

Level 9: Grammar Transformations
=================================

**Question 24:** Eliminate Œµ-productions from:

.. code-block:: text

   S ‚Üí aS | A
   A ‚Üí bA | Œµ

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

**Step 1: Find nullable variables**

- A is nullable (A ‚Üí Œµ directly)
- S is not nullable

**Step 2: Generate new productions**

Original productions with nullable A:

- S ‚Üí aS (no A, keep as-is)
- S ‚Üí A (A is nullable, so add S ‚Üí Œµ)

For A:

- A ‚Üí bA (A is nullable, so add A ‚Üí b)
- Remove A ‚Üí Œµ

**Final grammar:**

.. code-block:: text

   S ‚Üí aS | A | Œµ
   A ‚Üí bA | b

.. admonition:: Concept Note
   :class: tip

   For each production with a nullable variable, create versions with and without it.

.. raw:: html

   </details>

----

**Question 25:** Convert to Chomsky Normal Form:

.. code-block:: text

   S ‚Üí aSb | ab

.. raw:: html

   <details>
   <summary><strong>üìò SOLUTION (Click to Expand)</strong></summary>

**Step 1: Eliminate terminals in length > 1 productions**

.. code-block:: text

   S ‚Üí ASB | AB
   A ‚Üí a
   B ‚Üí b

**Step 2: Break productions with length > 2**

S ‚Üí ASB has length 3, need to split:

.. code-block:: text

   S ‚Üí AX | AB
   X ‚Üí SB
   A ‚Üí a
   B ‚Üí b

**Final CNF:**

.. code-block:: text

   S ‚Üí AX | AB
   X ‚Üí SB
   A ‚Üí a
   B ‚Üí b

.. admonition:: CNF Requirements
   :class: tip

   All productions must be:
   - A ‚Üí BC (two non-terminals), or
   - A ‚Üí a (single terminal)

.. raw:: html

   </details>





----

Level 8: Language Classification & Impossibilities
===================================================

.. admonition:: **Question 26 (Classification):** Which of the following languages can be accepted by a PDA (is context-free)?

    A) :math:`L = \{a^n b^n c^n \mid n \geq 1\}`
    
    B) :math:`L = \{a^n b^n \mid n \geq 1\}`
    
    C) :math:`L = \{ww^R \mid w \in \{a,b\}^*\}`
    
    D) All of the above

    .. raw:: html

        <span class="level-indicator level-advanced">ADVANCED</span>

    **Solution:**

    .. raw:: html

        <details>
        <summary><b>üîç Show Complete Solution</b></summary>

    .. raw:: html

        <div class="not-possible">
        Answer: Only B and C are CFLs
        </div>

    .. raw:: html

        <div class="steps-box">
        <strong>üéØ Analysis:</strong>
        <ol>
        <li><strong>A) a<sup>n</sup>b<sup>n</sup>c<sup>n</sup>:</strong> ‚úó NOT context-free
            <ul>
            <li>Requires THREE equal counts simultaneously</li>
            <li>PDA has only ONE stack</li>
            <li>Can match at most TWO counts</li>
            <li>This is Context-Sensitive (needs LBA)</li>
            </ul>
        </li>
        <li><strong>B) a<sup>n</sup>b<sup>n</sup>:</strong> ‚úì Context-free
            <ul>
            <li>Classic CFL pattern</li>
            <li>Push for a's, pop for b's</li>
            <li>PDA can handle this easily</li>
            </ul>
        </li>
        <li><strong>C) ww<sup>R</sup>:</strong> ‚úì Context-free
            <ul>
            <li>Even-length palindromes</li>
            <li>Push first half, match second half</li>
            <li>Non-deterministically guess middle</li>
            </ul>
        </li>
        </ol>
        </div>

    .. raw:: html

        <div class="highlight-note">
        <strong>Key Pattern:</strong> PDAs can handle TWO equal counts or palindromes, but NOT three equal counts.
        </div>

    .. raw:: html

        </details>

----

.. admonition:: **Question 27 (Impossibility):** Prove that :math:`L = \{a^{n!} \mid n \geq 0\}` (factorial) is NOT context-free.

    .. raw:: html

        <span class="level-indicator level-advanced">ADVANCED</span>

    **Solution:**

    .. raw:: html

        <details>
        <summary><b>üîç Show Complete Solution</b></summary>

    .. raw:: html

        <div class="not-possible">
        NOT POSSIBLE with a PDA
        </div>

    .. raw:: html

        <div class="steps-box">
        <strong>üéØ Why Factorial Growth Fails:</strong>
        <ol>
        <li><strong>Language Description:</strong> Strings with 1, 1, 2, 6, 24, 120,... a's</li>
        <li><strong>Growth Rate:</strong> Factorial grows faster than exponential</li>
        <li><strong>Why PDA Fails:</strong>
            <ul>
            <li>PDAs can handle LINEAR relationships (a<sup>n</sup>b<sup>n</sup>)</li>
            <li>Cannot handle SUPER-EXPONENTIAL growth</li>
            <li>Stack can only count linearly</li>
            </ul>
        </li>
        <li><strong>Pumping Lemma Proof:</strong>
            <ul>
            <li>Let p be pumping length</li>
            <li>Consider w = a<sup>p!</sup></li>
            <li>Pumping adds/removes linear amount k</li>
            <li>p! + k is not a factorial for suitable k</li>
            <li>Gap between consecutive factorials grows too fast</li>
            </ul>
        </li>
        </ol>
        </div>

    .. raw:: html

        <div class="example-box">
        üí≠ <strong>Pattern:</strong> Languages with non-polynomial growth (factorial, exponential of exponential) are NOT context-free.
        </div>

    .. raw:: html

        </details>

----

.. admonition:: **Question 28 (Impossibility):** Prove that :math:`L = \{a^{n^m} \mid n, m \geq 1\}` (exponential) is NOT context-free.

    .. raw:: html

        <span class="level-indicator level-advanced">ADVANCED</span>

    **Solution:**

    .. raw:: html

        <details>
        <summary><b>üîç Show Complete Solution</b></summary>

    .. raw:: html

        <div class="not-possible">
        NOT POSSIBLE with a PDA
        </div>

    .. raw:: html

        <div class="steps-box">
        <strong>üéØ Why Exponential Powers Fail:</strong>
        <ol>
        <li><strong>Language Description:</strong> 
            <ul>
            <li>n=2, m=2: a<sup>4</sup></li>
            <li>n=2, m=3: a<sup>8</sup></li>
            <li>n=3, m=2: a<sup>9</sup></li>
            </ul>
        </li>
        <li><strong>The Challenge:</strong>
            <ul>
            <li>Not all powers are included (only those of form n<sup>m</sup>)</li>
            <li>Cannot distinguish n<sup>m</sup> from other numbers</li>
            <li>PDA cannot verify this property</li>
            </ul>
        </li>
        <li><strong>Why PDA Fails:</strong>
            <ul>
            <li>Would need to verify: "Is |w| expressible as n<sup>m</sup>?"</li>
            <li>Requires arithmetic computation beyond linear counting</li>
            <li>Stack provides only linear counting mechanism</li>
            </ul>
        </li>
        </ol>
        </div>

    .. raw:: html

        <div class="highlight-note">
        <strong>General Principle:</strong> Languages requiring arithmetic verification (perfect squares, primes, exponentials) are NOT context-free.
        </div>

    .. raw:: html

        </details>

----

.. admonition:: **Question 29 (Impossibility):** Prove that :math:`L = \{a^n \mid n \text{ is prime}\}` is NOT context-free.

    .. raw:: html

        <span class="level-indicator level-advanced">ADVANCED</span>

    **Solution:**

    .. raw:: html

        <details>
        <summary><b>üîç Show Complete Solution</b></summary>

    .. raw:: html

        <div class="not-possible">
        NOT POSSIBLE with a PDA
        </div>

    .. raw:: html

        <div class="steps-box">
        <strong>üéØ Why Prime Numbers Fail:</strong>
        <ol>
        <li><strong>Language Description:</strong> Strings with 2, 3, 5, 7, 11, 13,... a's (only primes)</li>
        <li><strong>Why PDA Fails:</strong>
            <ul>
            <li>PDAs cannot perform primality testing</li>
            <li>No way to verify divisibility properties using a stack</li>
            <li>Would require checking: "Is |w| not divisible by any 2 ‚â§ k < |w|?"</li>
            <li>This needs unbounded divisibility checks</li>
            </ul>
        </li>
        <li><strong>Pumping Lemma Approach:</strong>
            <ul>
            <li>Consider a large prime p</li>
            <li>Pumping w = a<sup>p</sup> gives uv<sup>i</sup>xy<sup>i</sup>z</li>
            <li>Length = p + (i-1)|vy|</li>
            <li>Can choose i to make this composite</li>
            <li>For example, i = p+1 gives p + p¬∑|vy| = p(1 + |vy|) which is composite</li>
            </ul>
        </li>
        </ol>
        </div>

    .. raw:: html

        <div class="example-box">
        üí≠ <strong>Key Insight:</strong> Prime detection requires arithmetic beyond simple counting - it needs divisibility testing which PDAs cannot perform.
        </div>

    .. raw:: html

        </details>

----

.. admonition:: **Question 30 (Impossibility):** Prove that :math:`L = \{ww \mid w \in \{a,b\}^*\}` (exact copy) is NOT context-free.

    .. raw:: html

        <span class="level-indicator level-advanced">ADVANCED</span>

    **Solution:**

    .. raw:: html

        <details>
        <summary><b>üîç Show Complete Solution</b></summary>

    .. raw:: html

        <div class="not-possible">
        NOT POSSIBLE with a PDA
        </div>

    .. raw:: html

        <div class="steps-box">
        <strong>üéØ Why Copying (Forward) Fails:</strong>
        <ol>
        <li><strong>The Challenge:</strong> Need to verify second half is EXACT copy of first</li>
        <li><strong>Contrast with ww<sup>R</sup>:</strong>
            <ul>
            <li><strong>ww<sup>R</sup> (palindrome):</strong> ‚úì CFL - can use stack to verify reverse</li>
            <li><strong>ww (copy):</strong> ‚úó NOT CFL - would need to verify forward copy</li>
            </ul>
        </li>
        <li><strong>Why PDA Fails:</strong>
            <ul>
            <li>LIFO (Last-In-First-Out) structure of stack</li>
            <li>Can only compare in REVERSE order</li>
            <li>Cannot "remember" first half in forward order AND compare</li>
            <li>Would need FIFO queue or two stacks (= Turing Machine)</li>
            </ul>
        </li>
        <li><strong>Pumping Lemma Proof:</strong>
            <ul>
            <li>Consider w = a<sup>p</sup>b<sup>p</sup>a<sup>p</sup>b<sup>p</sup></li>
            <li>Any decomposition uvxyz with |vxy| ‚â§ p</li>
            <li>vxy lies entirely in one or two adjacent blocks</li>
            <li>Pumping disrupts the ww pattern</li>
            <li>Cannot maintain exact duplication</li>
            </ul>
        </li>
        </ol>
        </div>

    .. raw:: html

        <div class="highlight-note">
        <strong>Critical Distinction:</strong> The ORDER of comparison matters!
        <ul>
        <li>ww<sup>R</sup> is CFL (reverse comparison via stack)</li>
        <li>ww is NOT CFL (forward comparison impossible with single stack)</li>
        </ul>
        </div>

    .. raw:: html

        </details>

----

.. admonition:: **Question 31 (Impossibility):** Prove that :math:`L = \{w^n \mid w \in \{a,b\}^*, n \geq 1\}` (n copies) is NOT context-free.

    .. raw:: html

        <span class="level-indicator level-advanced">ADVANCED</span>

    **Solution:**

    .. raw:: html

        <details>
        <summary><b>üîç Show Complete Solution</b></summary>

    .. raw:: html

        <div class="not-possible">
        NOT POSSIBLE with a PDA
        </div>

    .. raw:: html

        <div class="steps-box">
        <strong>üéØ Why Multiple Copies Fail:</strong>
        <ol>
        <li><strong>Language Description:</strong>
            <ul>
            <li>Examples: aa, abab, aabaabab (w=ab, n=2)</li>
            <li>Need to verify ALL copies are identical</li>
            </ul>
        </li>
        <li><strong>Special Cases:</strong>
            <ul>
            <li><strong>n=1:</strong> w<sup>1</sup> = all strings (trivially CFL)</li>
            <li><strong>n=2:</strong> ww (NOT CFL as proven in Q30)</li>
            <li><strong>n=3:</strong> www (even harder than ww)</li>
            </ul>
        </li>
        <li><strong>Why PDA Fails:</strong>
            <ul>
            <li>Cannot verify multiple identical copies</li>
            <li>Would need to compare first copy with second, AND with third, etc.</li>
            <li>Even checking www requires comparing THREE segments</li>
            <li>PDA can only track one relationship at a time</li>
            </ul>
        </li>
        <li><strong>Proof Approach:</strong>
            <ul>
            <li>If w<sup>n</sup> were CFL, then ww (n=2 case) would be CFL</li>
            <li>But ww is NOT CFL (proven)</li>
            <li>Therefore w<sup>n</sup> is NOT CFL</li>
            </ul>
        </li>
        </ol>
        </div>

    .. raw:: html

        <div class="example-box">
        üí≠ <strong>Pattern:</strong> Any language requiring comparison of multiple forward copies is NOT context-free.
        </div>

    .. raw:: html

        </details>

----

.. admonition:: **Question 32 (Impossibility):** Is :math:`L = \{www^R \mid w \in \{a,b\}^*\}` context-free?

    .. raw:: html

        <span class="level-indicator level-advanced">ADVANCED</span>

    **Solution:**

    .. raw:: html

        <details>
        <summary><b>üîç Show Complete Solution</b></summary>

    .. raw:: html

        <div class="not-possible">
        NOT POSSIBLE with a PDA
        </div>

    .. raw:: html

        <div class="steps-box">
        <strong>üéØ Why www<sup>R</sup> Fails:</strong>
        <ol>
        <li><strong>Language Description:</strong> Three copies of w, with last one reversed
            <ul>
            <li>Example: w = ab ‚Üí string is "ab ab ba"</li>
            <li>Need first two copies to match (forward) AND third to be reverse</li>
            </ul>
        </li>
        <li><strong>Two Challenges Combined:</strong>
            <ul>
            <li><strong>Challenge 1:</strong> Verify first two copies are identical (like ww)</li>
            <li><strong>Challenge 2:</strong> Verify third copy is reverse (like ww<sup>R</sup>)</li>
            <li>While ww<sup>R</sup> alone is CFL, adding ww pattern makes it non-CFL</li>
            </ul>
        </li>
        <li><strong>Why PDA Fails:</strong>
            <ul>
            <li>Cannot simultaneously:
                <ul>
                <li>Compare first two w's (forward comparison - impossible)</li>
                <li>AND verify third w matches in reverse</li>
                </ul>
            </li>
            <li>Would need to "remember" first w in forward order</li>
            <li>While also preparing to match reverse of second w</li>
            <li>This requires more than one stack's worth of memory</li>
            </ul>
        </li>
        <li><strong>Formal Proof Sketch:</strong>
            <ul>
            <li>If www<sup>R</sup> were CFL, could intersect with regular language a<sup>*</sup>b<sup>*</sup>a<sup>*</sup>b<sup>*</sup>b<sup>*</sup>a<sup>*</sup></li>
            <li>Would give {a<sup>n</sup>b<sup>n</sup>a<sup>n</sup>b<sup>n</sup>b<sup>n</sup>a<sup>n</sup>}</li>
            <li>This is similar to crossed dependencies - NOT CFL</li>
            </ul>
        </li>
        </ol>
        </div>

    .. raw:: html

        <div class="highlight-note">
        <strong>Key Insight:</strong> Adding forward-copy constraint (ww) to palindrome pattern (ww<sup>R</sup>) creates a language beyond CFL power.
        </div>

    .. raw:: html

        </details>

----

Summary: What Makes Languages Non-Context-Free
===============================================

.. raw:: html

   <div class="pda-box">
   <strong>üéØ Patterns That CANNOT Be Handled by PDAs:</strong><br><br>
   
   <strong>1. Three or More Equal Counts:</strong><br>
   ‚Ä¢ a<sup>n</sup>b<sup>n</sup>c<sup>n</sup> - needs to track three relationships<br>
   ‚Ä¢ Requires more than one stack<br><br>
   
   <strong>2. Forward Copying:</strong><br>
   ‚Ä¢ ww - needs to remember and compare in same direction<br>
   ‚Ä¢ w<sup>n</sup> - multiple forward copies<br>
   ‚Ä¢ Stack is LIFO, can only compare in reverse<br><br>
   
   <strong>3. Arithmetic Properties:</strong><br>
   ‚Ä¢ Primes: a<sup>n</sup> where n is prime<br>
   ‚Ä¢ Perfect squares: a<sup>n¬≤</sup><br>
   ‚Ä¢ Factorials: a<sup>n!</sup><br>
   ‚Ä¢ Exponentials: a<sup>n^m</sup><br>
   ‚Ä¢ Requires divisibility testing or complex arithmetic<br><br>
   
   <strong>4. Crossed Dependencies:</strong><br>
   ‚Ä¢ a<sup>i</sup>b<sup>j</sup>c<sup>k</sup>d<sup>l</sup> where i=k AND j=l<br>
   ‚Ä¢ Two independent equalities that "cross" each other<br><br>
   
   <strong>5. Mixed Constraints:</strong><br>
   ‚Ä¢ www<sup>R</sup> - combines copying with reverse<br>
   ‚Ä¢ Multiple simultaneous conditions
   </div>

.. raw:: html

   <div class="highlight-note">
   <strong>‚ö° Why These Fail:</strong><br><br>
   
   <strong>PDA Limitations:</strong><br>
   ‚Ä¢ Only ONE stack (LIFO structure)<br>
   ‚Ä¢ Can track at most ONE relationship<br>
   ‚Ä¢ Can compare only in REVERSE order<br>
   ‚Ä¢ Cannot perform arithmetic beyond counting<br><br>
   
   <strong>What's Needed:</strong><br>
   ‚Ä¢ Two stacks ‚Üí Linear Bounded Automaton (LBA)<br>
   ‚Ä¢ Full tape ‚Üí Turing Machine<br>
   ‚Ä¢ Multiple simultaneous counters ‚Üí Beyond CFLs
   </div>

.. raw:: html

   <div class="steps-box">
   <strong>üéì Proof Techniques:</strong><br>
   <ol>
   <li><strong>Pumping Lemma for CFLs:</strong> Show no matter how you pump, language membership breaks</li>
   <li><strong>Closure Properties:</strong> Show if L were CFL, then intersecting with regular language gives known non-CFL</li>
   <li><strong>Reduction:</strong> Show if L were CFL, then another known non-CFL would also be CFL (contradiction)</li>
   <li><strong>Direct Argument:</strong> Show inherent limitation of PDA (like LIFO for ww)</li>
   </ol>
   </div>

----


----

Summary: CFG Patterns Reference
================================

.. admonition:: Essential Grammar Patterns
   :class: hint

   **1. Equal Count (a^n b^n):**
   
   .. code-block:: text
   
      S ‚Üí aSb | ab
   
   **2. Palindromes:**
   
   .. code-block:: text
   
      S ‚Üí aSa | bSb | a | b | Œµ
   
   **3. Independent Counts (a^n b^m):**
   
   .. code-block:: text
   
      S ‚Üí AB
      A ‚Üí aA | a
      B ‚Üí bB | b
   
   **4. Nested Dependencies (a^n b^n c^m d^m):**
   
   .. code-block:: text
   
      S ‚Üí XY
      X ‚Üí aXb | ab
      Y ‚Üí cYd | cd
   
   **5. Position Constraints:**
   
   .. code-block:: text
   
      S ‚Üí aXb  (starts 'a', ends 'b')
      X ‚Üí aX | bX | Œµ


.. admonition:: What CFGs Can and Cannot Do
   :class: tip

   **‚úì CFGs CAN handle:**
   
   - Two equal counts (a^n b^n)
   - Palindromes (ww^R)
   - Balanced structures (parentheses)
   - Nested dependencies
   - Position constraints
   
   **‚úó CFGs CANNOT handle:**
   
   - Three equal counts (a^n b^n c^n)
   - Copying (ww)
   - Crossed dependencies
   - Non-linear counting (primes, squares)
   - Context-sensitive patterns

----
