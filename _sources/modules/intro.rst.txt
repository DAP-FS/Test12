==================
Best Practices
==================


.. admonition:: **Question 1:** Construct a grammar that accepts the set of all strings of length 2 (:math:`\Sigma = \{a, b\}`).

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to X X \\
        X \to a \mid b

    **Step-by-step (easy):**

    1. We want strings of exactly length 2.
    2. Introduce a symbol :math:`X` that generates a single character (:math:`a` or :math:`b`).
    3. The start symbol :math:`S` should produce two :math:`X` in sequence, so :math:`S \to X X`.
    4. This allows all four strings: :math:`aa, ab, ba, bb`.

        </details>

.. admonition:: **Question 2:** Grammar for :math:`L = \{ a^n b^m \mid n \ge 1, m \ge 1 \}`.

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to A B \\
        A \to a A \mid a \\
        B \to b B \mid b

    **Step-by-step (easy):**

    1. The language is some positive number of :math:`a` followed by some positive number of :math:`b`.
    2. Use :math:`A` to generate one or more :math:`a`'s (:math:`n \ge 1`): :math:`A \to a A \mid a`.
    3. Use :math:`B` to generate one or more :math:`b`'s (:math:`m \ge 1`): :math:`B \to b B \mid b`.
    4. The start symbol :math:`S` concatenates them: :math:`S \to A B`.
    5. Example: to produce :math:`aaab`, expand :math:`S \to A B`, :math:`A \to a A \to a a A \to a a a`, and :math:`B \to b`.

        </details>

.. admonition:: **Question 3:** Grammar for :math:`L = \{ a^n b^n \mid n \ge 0 \}`.

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to a S b \mid \epsilon

    **Step-by-step (easy):**

    1. We must produce equal numbers of :math:`a` and :math:`b`, with all :math:`a` before :math:`b`.
    2. The rule :math:`S \to a S b` adds one :math:`a` at the left and one :math:`b` at the right together — that keeps the counts equal.
    3. The base :math:`S \to \epsilon` handles the case :math:`n = 0` (empty string).
    4. Example: For :math:`n=2`, expand :math:`S \to a S b \to a a S b b \to a a \epsilon b b = a a b b`.

        </details>

.. admonition:: **Question 4:** Set of strings of length at least 2 (:math:`\Sigma = \{a, b\}`).

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to X X Y \\
        X \to a \mid b \\
        Y \to a Y \mid b Y \mid \epsilon

    **Step-by-step (easy):**

    1. We must generate any string whose length is **≥ 2**.
    2. Ensure at least two characters by requiring two occurrences of :math:`X` at the start: :math:`S \to X X Y`.
    3. :math:`X` generates a single symbol (:math:`a` or :math:`b`). So :math:`X X` guarantees two symbols minimum.
    4. :math:`Y` generates the rest of the string, which can be any length (including zero) from the set :math:`\Sigma^*`. The rules for :math:`Y` are equivalent to :math:`(a \mid b)^*`.

        </details>

.. admonition:: **Question 5:** Set of strings of length at most 2 (:math:`\Sigma = \{a, b\}`).

    **Solution (hidden):
    >

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to \epsilon \mid X \mid X X \\
        X \to a \mid b

    **Step-by-step (easy):**

    1. Strings allowed: length 0, 1, or 2.
    2. Use the alternatives: empty string (:math:`\epsilon`), one symbol (:math:`X`), or two symbols (:math:`X X`).
    3. Define :math:`X` as a single letter :math:`a` or :math:`b`.
    4. This covers :math:`\{\epsilon, a, b, aa, ab, ba, bb\}`.

        </details>

.. admonition:: **Question 6:** Set of strings starting with :math:`a` and ending with :math:`b` (:math:`\Sigma = \{a, b\}`).

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to a X b \mid a b \\
        X \to a X \mid b X \mid \epsilon

    **Step-by-step (easy):**

    1. Every string must begin with :math:`a` and end with :math:`b`.
    2. The base case is the minimal string :math:`ab`, handled by :math:`S \to a b`.
    3. For longer strings, use :math:`S \to a X b`, where :math:`X` generates any string of length $\ge 1$.
    4. The non-terminal :math:`X` generates any string from :math:`\Sigma^*` using the rules :math:`X \to a X \mid b X \mid \epsilon`. The overall grammar must include the minimal string :math:`ab`.

        </details>

.. admonition:: **Question 7:** Set of strings starting and ending with different symbols (:math:`\Sigma = \{a, b\}`).

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to A \mid B \\
        A \to a X b \\
        B \to b X a \\
        X \to a X \mid b X \mid a \mid b \mid \epsilon

    **Step-by-step (easy):**

    1. The language is the union of two cases: (Starts with :math:`a` and ends with :math:`b`) OR (Starts with :math:`b` and ends with :math:`a`).
    2. Use :math:`S \to A \mid B` to separate the cases.
    3. :math:`A \to a X b` covers the first case. :math:`B \to b X a` covers the second case.
    4. The non-terminal :math:`X` generates any string from :math:`\Sigma^*`, ensuring all strings of length $\ge 2$ (e.g., :math:`ab`, :math:`ba`) are covered. The rule :math:`X \to \epsilon` handles the length 2 strings, while :math:`X \to a \mid b` handles length 3 strings like :math:`aab` and :math:`baa`.

        </details>

.. admonition:: **Question 8:** Set of all strings starting and ending with the same symbol (:math:`\Sigma = \{a, b\}`).

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to a X a \mid b X b \mid a \mid b \mid \epsilon \\
        X \to a X \mid b X \mid \epsilon

    **Step-by-step (easy):**

    1. This includes four sub-cases:
        a. Strings of length $\ge 2$ starting and ending with :math:`a`: :math:`a X a`.
        b. Strings of length $\ge 2$ starting and ending with :math:`b`: :math:`b X b`.
        c. Strings of length 1 (:math:`a` or :math:`b`).
        d. String of length 0 (:math:`\epsilon`).
    2. The production :math:`S \to a \mid b \mid \epsilon` handles cases (c) and (d).
    3. The productions :math:`S \to a X a \mid b X b` handle cases (a) and (b).
    4. :math:`X \to a X \mid b X \mid \epsilon` generates any possible middle section :math:`\Sigma^*`.

        </details>

.. admonition:: **Question 9:** Grammar for :math:`L = \{ a^n b^n c^m \mid n \ge 0, m \ge 0 \}`.

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to A B \\
        A \to a A b \mid \epsilon \\
        B \to c B \mid \epsilon

    **Step-by-step (easy):**

    1. The language is a sequence of equal :math:`a`'s and :math:`b`'s, followed by any number of :math:`c`'s. This suggests concatenation of two independent parts.
    2. Use non-terminal :math:`A` for the equal :math:`a^n b^n` part (CFG is required here): :math:`A \to a A b \mid \epsilon`.
    3. Use non-terminal :math:`B` for the arbitrary :math:`c^m` part (Regular Grammar is sufficient): :math:`B \to c B \mid \epsilon`.
    4. Concatenate them: :math:`S \to A B`.

        </details>

.. admonition:: **Question 10:** Set of all palindromes (:math:`w = w^R, \Sigma = \{a, b\}`).

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to a S a \mid b S b \mid a \mid b \mid \epsilon

    **Step-by-step (easy):**

    1. Palindromes must read the same forward and backward.
    2. The recursive rules :math:`S \to a S a \mid b S b` ensure that whatever is added to the left is also added to the right, preserving the palindrome property.
    3. The base cases cover:
        a. Odd-length palindromes (middle symbol): :math:`S \to a \mid b`.
        b. Even-length palindromes (empty middle): :math:`S \to \epsilon`.
    4. Example: :math:`aba` from :math:`S \to a S a \to a b a`. Example: :math:`abba` from :math:`S \to a S a \to a b S b a \to a b \epsilon b a = a b b a`.

        </details>

.. admonition:: **Question 11:** Even length strings (:math:`|w| = 2k, k \ge 0, \Sigma = \{a, b\}`).

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to X X S \mid \epsilon \\
        X \to a \mid b

    **Step-by-step (easy):**

    1. We want strings where the length is a multiple of 2 (0, 2, 4, ...).
    2. The recursive rule must add symbols in pairs.
    3. :math:`S \to X X S` adds two symbols (:math:`X X`) and continues the process (:math:`S`).
    4. The base case :math:`S \to \epsilon` stops the recursion, resulting in an even length.
    5. :math:`X \to a \mid b` generates a single character.

        </details>

.. admonition:: **Question 12:** Grammar for :math:`L = \{ w \mid |w| \equiv 0 \pmod 3, \Sigma = \{a, b\} \}`. (Length is a multiple of 3)

    **Solution (hidden):**

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to X X X S \mid \epsilon \\
        X \to a \mid b

    **Step-by-step (easy):**

    1. We want strings where the length is a multiple of 3 (0, 3, 6, 9, ...).
    2. The recursive rule must add symbols in triplets.
    3. :math:`S \to X X X S` adds three symbols (:math:`X X X`) and continues the process (:math:`S`).
    4. The base case :math:`S \to \epsilon` stops the recursion, resulting in a length divisible by 3.
    5. :math:`X \to a \mid b` generates a single character.

        </details>

.. admonition:: **Question 13:** Grammar for :math:`L = \{ a^n b^n c^n \mid n \ge 0 \}`.

    **Solution (hidden):</b>

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    **Not possible with a Context-Free Grammar (CFG).**

    **Step-by-step (easy):**

    1. The language requires three separate components to have equal counts: :math:`Count(a) = Count(b) = Count(c)`.
    2. A CFG pushdown automaton (PDA) can only simultaneously enforce the equality of two counts (e.g., :math:`a^n b^n`) using its single stack.
    3. To enforce the third equality (:math:`Count(c)=n`), the PDA would need a second stack.
    4. Since :math:`L = \{ a^n b^n c^n \mid n \ge 0 \}` is a **Context-Sensitive Language** (CSL), it cannot be generated by a CFG.

        </details>

.. admonition:: **Question 14:** Grammar for :math:`L = \{ a^n b^m \mid n > m, n \ge 0, m \ge 0 \}`. (More :math:`a`'s than :math:`b`'s)

    **Solution (hidden):</b>

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to A B \\
        A \to a A b \mid a \\
        B \to a B \mid \epsilon

    **Step-by-step (easy):**

    1. The language requires a minimal string of one extra :math:`a` (:math:`a^{m+1} b^m`), followed by any number of additional :math:`a`'s.
    2. The CFG needs to first match :math:`a^m b^m` and then ensure the single extra :math:`a`.
    3. Use non-terminal :math:`A` to enforce the *at least one extra* :math:`a`: :math:`A \to a A b` matches the $m$ pairs, and the minimal production :math:`A \to a` guarantees the one extra $a$.
    4. Use non-terminal :math:`B` to generate any arbitrary number of $a$'s at the end (the $a$'s not needed for matching $b$'s): :math:`B \to a B \mid \epsilon`.
    5. Concatenate them: :math:`S \to A B`.

        </details>

.. admonition:: **Question 15:** Grammar for :math:`L = \{ a^n b^m \mid n \ne m, n \ge 0, m \ge 0 \}`. (Unequal numbers of :math:`a`'s and :math:`b`'s)

    **Solution (hidden):</b>

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to A \mid B \\
        A \to a A b \mid a C \\
        B \to a B b \mid b C \\
        C \to a C \mid b C \mid \epsilon

    **Step-by-step (easy):**

    1. The language is the union of two independent cases: **Case A: More :math:`a`'s than :math:`b`'s** (covered by $A$) OR **Case B: More :math:`b`'s than :math:`a`'s** (covered by $B$).
    2. **Case A (n > m):** Match the pairs with :math:`A \to a A b`, and then use :math:`A \to a C` to enforce one extra :math:`a` followed by any remaining :math:`a`'s or :math:`b`'s generated by :math:`C`.
    3. **Case B (m > n):** Match the pairs with :math:`B \to a B b`, and then use :math:`B \to b C` to enforce one extra :math:`b` followed by any remaining symbols.
    4. :math:`C \to a C \mid b C \mid \epsilon` generates any string :math:`\Sigma^*`.

        </details>

.. admonition:: **Question 16:** Grammar for :math:`L = \{ a^n b^n c^m d^m \mid n \ge 0, m \ge 0 \}`.

    **Solution (hidden):</b>

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to A B \\
        A \to a A b \mid \epsilon \\
        B \to c B d \mid \epsilon

    **Step-by-step (easy):**

    1. The language consists of two independent parts concatenated: :math:`(a^n b^n)` followed by :math:`(c^m d^m)`.
    2. Use :math:`A` for the first part: :math:`A \to a A b \mid \epsilon`. This ensures :math:`Count(a) = Count(b)`.
    3. Use :math:`B` for the second part: :math:`B \to c B d \mid \epsilon`. This ensures :math:`Count(c) = Count(d)`.
    4. Since the two parts are independent and adjacent, a CFG can handle it: :math:`S \to A B`. This language is the intersection of two CFGs, but since they are distinct parts of the string, the grammar is simple.

        </details>

.. admonition:: **Question 17:** Grammar for :math:`L = \{ w w^R \mid w \in \{a, b\}^* \}`. (Even-length palindromes)

    **Solution (hidden):</b>

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to a S a \mid b S b \mid \epsilon

    **Step-by-step (easy):**

    1. This is the subset of palindromes that must have an **even length** (since :math:`w w^R` is always $2|w|$).
    2. The recursive rules :math:`S \to a S a \mid b S b` enforce the palindrome structure by adding identical symbols to the ends.
    3. The only base case is the empty string :math:`S \to \epsilon`, which correctly generates the smallest even-length palindrome (length 0).
    4. The rules from Question 10 (Palindromes) *without* the $S \to a \mid b$ productions are exactly what is needed here.

        </details>

.. admonition:: **Question 18:** Grammar for :math:`L = \{ a^i b^j c^k \mid i = j \text{ or } j = k \}`.

    **Solution (hidden):</b>

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to A \mid B \\
        A \to C D \\
        C \to a C b \mid \epsilon \\
        D \to c D \mid \epsilon \\
        B \to E F \\
        E \to a E \mid \epsilon \\
        F \to b F c \mid \epsilon

    **Step-by-step (easy):**

    1. The language is the union of two CFGs: **Case A**: :math:`i = j` (arbitrary :math:`k`) OR **Case B**: :math:`j = k` (arbitrary :math:`i`).
    2. :math:`S \to A \mid B` separates the two cases.
    3. **Case A (:math:`i=j`):** :math:`A \to C D`. $C$ generates :math:`a^i b^i` ($C \to a C b \mid \epsilon$) and $D$ generates arbitrary $c$'s ($D \to c D \mid \epsilon$).
    4. **Case B (:math:`j=k`):** :math:`B \to E F`. $E$ generates arbitrary $a$'s ($E \to a E \mid \epsilon$) and $F$ generates :math:`b^j c^j` ($F \to b F c \mid \epsilon$).

        </details>

.. admonition:: **Question 19:** Grammar for :math:`L = \{ a^n b^n c^m d^m \mid n \ge 1, m \ge 1 \}`.

    **Solution (hidden):</b
    >

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to A B \\
        A \to a A b \mid a b \\
        B \to c B d \mid c d

    **Step-by-step (easy):**

    1. This is almost identical to Question 16, but with the constraint that $n \ge 1$ and $m \ge 1$ (no empty strings for $a^n b^n$ or $c^m d^m$).
    2. Use :math:`A` for the :math:`a^n b^n` part, guaranteeing $n \ge 1$: :math:`A \to a A b \mid a b`.
    3. Use :math:`B` for the :math:`c^m d^m` part, guaranteeing $m \ge 1$: :math:`B \to c B d \mid c d`.
    4. Concatenate them: :math:`S \to A B`.

        </details>

.. admonition:: **Question 20:** Grammar for :math:`L = \{ a^n b^n c^n \mid n \ge 1 \}`.

    **Solution (hidden):</b>

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    **Not possible with a Context-Free Grammar (CFG).**

    **Step-by-step (easy):**

    1. This is the same language as Question 13, but excludes the empty string (:math:`n=0`).
    2. The core constraint :math:`Count(a) = Count(b) = Count(c)` requires the PDA to track three counts simultaneously, which is impossible with a single stack.
    3. This language is a classic example used in the Pumping Lemma for CFGs to prove it is **not context-free**.

        </details>

.. admonition:: **Question 21:** Grammar for :math:`L = \{ w \mid w \text{ has equal numbers of } a\text{'s and } b\text{'s} \}`.

    **Solution (hidden):</b>

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to S S \mid a S b \mid b S a \mid \epsilon

    **Step-by-step (easy):**

    1. This is a classic non-regular CFG where the order of :math:`a`'s and :math:`b`'s does not matter, only that they cancel out to zero difference.
    2. :math:`S \to S S` allows concatenation (e.g., :math:`aabb` followed by :math:`bbaa` is valid).
    3. :math:`S \to a S b` and :math:`S \to b S a` ensure that one :math:`a` and one :math:`b` are generated together, preserving the equality count.
    4. :math:`S \to \epsilon` is the base case (empty string is valid).
    5. This grammar generates strings like :math:`ab, ba, aabb, abab, abba, baab`, etc., all with $N_a = N_b$.

        </details>

.. admonition:: **Question 22:** Grammar for :math:`L = \{ w \mid N_a(w) > N_b(w) \}`. (More :math:`a`'s than :math:`b`'s, any order)

    **Solution (hidden):</b>

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    .. math::
        S \to A \\
        A \to a \mid a A \mid b A a A \mid a A b A

    **Step-by-step (easy):**

    1. This is a well-known example that is a CFG, but complex to construct. The goal is to ensure the final string has a net surplus of one or more :math:`a`'s.
    2. We use recursion to ensure that all balanced pairs of :math:`a`'s and :math:`b`'s are generated, and a single :math:`a` is left over.
    3. The rule :math:`A \to a` ensures the minimum of one extra :math:`a`.
    4. The rules :math:`A \to a A`, :math:`A \to a A b A`, and :math:`A \to b A a A` ensure that we can generate any arbitrary string while maintaining the overall property of $N_a > N_b$. (A simpler form using an intermediate non-terminal is also possible but often more complex to prove correct.)

        </details>

.. admonition:: **Question 23:** CYK Algorithm Question: Check whether the string :math:`w=aab` is a valid member of the grammar :math:`G` where the productions are: :math:`S \to AB \mid BC`, :math:`A \to BA \mid a`, :math:`B \to CC \mid b`, :math:`C \to AB \mid a`.

    **Solution (hidden):</b>

    .. raw:: html

        <details>
        <summary><b>Show Solution</b></summary>

    **CYK Table:**

    The CYK table for :math:`w = a_1 a_2 b_3` (length 3):

    | Length $l$ | 1 | 2 | 3 |
    | :---: | :---: | :---: | :---: |
    | **$V_{i, 1}$** | :math:`V_{1,1}` ($a$) | :math:`V_{2,1}` ($a$) | :math:`V_{3,1}` ($b$) |
    | **Sets** | :math:`\{A, C\}` | :math:`\{A, C\}` | :math:`\{B\}` |
    | **$V_{i, 2}$** | :math:`V_{1,2}` ($aa$) | :math:`V_{2,2}` ($ab$) | |
    | **Sets** | :math:`\emptyset` | :math:`\{S, A\}` | |
    | **$V_{1, 3}$** | :math:`V_{1,3}` ($aab$) | | |
    | **Sets** | :math:`\emptyset` | | |

    **Detailed Calculation:**

    1.  **Length 1 ($V_{i, 1}$):**
        * $V_{1, 1}$ (for $a$): $\{A, C\}$ (from $A \to a, C \to a$)
        * $V_{2, 1}$ (for $a$): $\{A, C\}$
        * $V_{3, 1}$ (for $b$): $\{B\}$ (from $B \to b$)

    2.  **Length 2 ($V_{i, 2}$):**
        * $V_{1, 2}$ (for $a_1 a_2 = aa$): Check $V_{1, 1} V_{2, 1} = \{A, C\} \{A, C\}$. Productions $AA, AC, CA, CC$. Only $B \to CC$ exists. $\implies V_{1, 2} = \{B\}$. (Correction: checking $V_{1, 1} V_{2, 1}$ gives $AA, AC, CA, CC$. The given grammar only has $S \to AB, BC$ etc.)
            * Let's re-check $V_{1, 2}$: $V_{1, 1} V_{2, 1} = \{A, C\} \{A, C\}$.
            * $A A$: Not possible.
            * $A C$: Not possible.
            * $C A$: Not possible.
            * $C C$: Possible from $B \to C C$. $\implies V_{1, 2} = \{B\}$. (My earlier table entry was wrong).

        * $V_{2, 2}$ (for $a_2 b_3 = ab$): Check $V_{2, 1} V_{3, 1} = \{A, C\} \{B\}$. Productions $A B, C B$.
            * $A B$: Possible from $S \to A B, C \to A B$. $\implies \{S, C\}$.
            * $C B$: Not possible.
            * $\implies V_{2, 2} = \{S, C\}$.

    3.  **Length 3 ($V_{1, 3}$):** Check all splits (k=1, 2):
        * **Split 1:** $V_{1, 1} V_{2, 2} = \{A, C\} \{S, C\}$. Productions $A S, A C, C S, C C$.
            * $C C$: Possible from $B \to C C$. $\implies \{B\}$
        * **Split 2:** $V_{1, 2} V_{3, 1} = \{B\} \{B\}$. Productions $B B$.
            * $B B$: Not possible.
        * $\implies V_{1, 3} = \{B\}$.

    **Conclusion:**

    Since the start symbol :math:`S` is **not** in the set :math:`V_{1, 3}` (the set for the full string $aab$), the string :math:`aab` is **NOT** a valid member of the language generated by grammar :math:`G`.

        </details>