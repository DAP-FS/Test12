=============================
Pushdown Automata (PDA)
=============================

.. contents::
   :local:
   :depth: 2

----

.. raw:: html

   <style>
     h2, h3 { color: #7B1113; }
     .admonition.hint { background: #E6F7FF; border-left: 6px solid #1890FF; }
     .admonition.note { background: #FFFBE6; border-left: 6px solid #FAAD14; }
     .admonition.exercise { background: #F0F5FF; border-left: 6px solid #2F54EB; }
     .admonition.quiz { background: #FFF1F0; border-left: 6px solid #FF4D4F; }
     .admonition.id-trace { background: #F5F5F5; border-left: 6px solid #722C2C; padding: 0.75em; }
     code.id-notation { background: #e8e8e8; padding: 0.2em 0.4em; font-family: monospace; }
   </style>

----

Introduction
============

A **Pushdown Automaton (PDA)** is the *minimal machine* that can recognize **languages with nested or hierarchical structure** using a stack.  
It is the natural computational counterpart to **Context-Free Grammars (CFGs)** for parsing **balanced patterns and matched constructs**.

A PDA can accept a language **either by final state** or **by empty stack**, and both acceptance modes are *equivalent in power* for context-free languages.

.. hint::

   PDAs extend finite automata with a **stack memory**, giving just enough power to match *opens with closes* (like parentheses or tags) ‚Äî but still simpler than a Turing machine.

----

Why PDA?
=========

* **DFA/NFA fail** on nested patterns because they have only finite memory.
* **PDA succeeds** by using a **stack** ‚Äî push on every open symbol, pop on each matching close, and accept when both input and stack align.

.. note::

   - A PDA adds one unbounded *LIFO* stack to a finite automaton.  
   - This lets it match recursive structures such as parentheses, expressions, or HTML tags.

----

Everyday Analogy
================

*HTML/XML nesting* or *balanced parentheses* follow the rule:  
"**What was opened last must close first**."  
That is exactly the **LIFO (Last-In-First-Out)** discipline of a stack.

Compilers, expression parsers, and markup validators all rely on this PDA principle.

----

Formal Definition
=================

A **PDA** is a 7-tuple:

.. math::

   M = (Q, Œ£, Œì, Œ¥, q_0, Z_0, F)

where:

- :math:`Q` ‚Äî finite set of states  
- :math:`Œ£` ‚Äî input alphabet  
- :math:`Œì` ‚Äî stack alphabet  
- :math:`Œ¥` ‚Äî transition relation  
- :math:`q_0` ‚Äî start state  
- :math:`Z_0` ‚Äî initial stack symbol  
- :math:`F` ‚Äî set of accepting states

A transition  
:math:`Œ¥(q, a, X) ‚Üí (p, Œ≥)`  
means: *in state q*, reading input symbol *a* (or Œµ), with *X* on top of stack ‚Äî  
**pop X**, and **push Œ≥** (possibly Œµ) while moving to *p*.

----

Instantaneous Description (ID) & Acceptance
============================================

Formal Notation
---------------

An **Instantaneous Description (ID)** is a triple:

.. math::

   (q, w, Œ±)

where:

- :math:`q` ‚Äî current state  
- :math:`w` ‚Äî remaining input (unconsumed symbols)  
- :math:`Œ±` ‚Äî stack contents (top-to-bottom, left-to-right)

**Turnstile Notation** ‚Äî The symbol :math:`\vdash` (turnstile) represents a single move:

.. math::

   (q, aw, XŒ≤) \vdash (q', w, Œ≥Œ≤)

means: from state :math:`q`, consuming input :math:`a`, with stack symbol :math:`X` on top, we move to state :math:`q'`, exposing the next input symbol, and replacing :math:`X` with string :math:`Œ≥`.

.. note::

   - :math:`\vdash` represents **one move**  
   - :math:`\vdash^*` represents **zero or more moves**  
   - A string :math:`w` is **accepted by final state** if :math:`(q_0, w, Z_0) \vdash^* (q_f, Œµ, Œ±)` where :math:`q_f \in F`  
   - A string :math:`w` is **accepted by empty stack** if :math:`(q_0, w, Z_0) \vdash^* (q, Œµ, Œµ)` for any state :math:`q`

----

Acceptance Modes
================

* **Acceptance by Final State** ‚Äî consume entire input and end in any state in *F*; stack contents may remain.  
* **Acceptance by Empty Stack** ‚Äî consume input and empty the stack; final state ignored.

.. hint::

   Both modes recognize **exactly the same class** of languages: *Context-Free Languages (CFLs)*.

----

Core Intuition ‚Äî Balanced Parentheses
=====================================

* Push a marker for each "(".
* Pop one for each ")".
* Reject if a pop is impossible or if the stack is non-empty at end (when using empty-stack acceptance).

This recognizes the classic **balanced parentheses language**, which DFAs cannot handle.

----

Minimal Recipe ‚Äî PDA for Balanced Parentheses
==============================================

* Input alphabet: ``(, )``  
* Stack symbols: ``(, $`` (where ``$`` marks stack bottom)
* Transitions:
  - On reading "(": **push ("(")**
  - On reading ")" with "(" on top: **pop**
  - At end: accept by final state or empty stack (via Œµ-move when only ``$`` remains)

.. admonition:: Example Construction
   :class: example

   States: q0 (start), q1 (loop), qf (final)  
   Stack start: ``$``  

   - q0 --Œµ, push($)--> q1  
   - q1 --'('-- push('(')--> q1  
   - q1 --')' with '(' on top-- pop('(')--> q1  
   - q1 --Œµ with only $ left-- goto qf  

   Accept either:
   * by **empty stack**, or  
   * by **final state qf**.

----

CFG ‚Üî PDA Equivalence
======================

Every **Context-Free Grammar (CFG)** has an equivalent **PDA**, and every PDA corresponds to some CFG.  
PDAs and CFGs therefore define the same language class: **Context-Free Languages (CFLs)**.

Conversion steps (CFG ‚Üí PDA):
1. Push the grammar's start symbol onto the stack.
2. Nondeterministically expand nonterminals by pushing productions.
3. Match input symbols by popping terminals.
4. Accept when stack is empty and input is consumed.

----

Regular vs. PDA
===============

+------------------+----------------------+-----------------------------+
| **Aspect**       | **DFA/NFA**          | **PDA**                     |
+==================+======================+=============================+
| Memory           | Fixed states only    | Unbounded stack (LIFO)     |
+------------------+----------------------+-----------------------------+
| Language Type    | Regular Languages    | Context-Free Languages      |
+------------------+----------------------+-----------------------------+
| Typical Pattern  | a*b*, even/odd count | Balanced parentheses, a‚Åøb‚Åø |
+------------------+----------------------+-----------------------------+
| Machine Power    | Finite               | Below Turing Machine        |
+------------------+----------------------+-----------------------------+

----

Why "Pushdown"?
===============

Because its working memory is a **pushdown stack** ‚Äî you *push* when starting a nested construct and *pop* when finishing it.  
This mirrors recursive structures and parser stacks in compilers.

----

Real-World Uses
===============

* **Parsing** programming languages (C, Java, Python)
* **Checking balanced delimiters** in code or XML
* **Validating arithmetic expressions** using grammar-based stack parsing

----

.. admonition:: Try it Yourself
   :class: exercise

   **Design a PDA for** :math:`L = \{ a^n b^n | n ‚â• 1 \}`  

   **Hint:**  
   Push a marker for each `a`; nondeterministically switch to popping phase on first `b`;  
   Pop one per `b`, and accept when input ends and stack is empty.

----

.. admonition:: Quick Check
   :class: quiz

   1. Can a DFA verify "(())"?  
      ‚Üí ‚úó No ‚Äî requires unbounded matching depth.  
   2. What can PDAs do that DFAs can't?  
      ‚Üí ‚úì Recognize recursive or nested structures.  
   3. Which automaton recognizes all CFLs?  
      ‚Üí ‚úì PDA.  
   4. Are final-state and empty-stack acceptance different in power?  
      ‚Üí ‚úó No ‚Äî equivalent.  

----

Definition 3.1 ‚Äî Pushdown Automaton
====================================

A **Pushdown Automaton (PDA)** is a tuple:

.. math::

   M = (Q, Œ£, Œì, Œ¥, q_0, Z_0, F)

where Œ¥ describes moves that read an input symbol or Œµ, pop one stack symbol, and push zero or more stack symbols.  
Acceptance is by **final state** or **empty stack**, and both recognize **context-free languages**.

----

PDA Example 1: Balanced Parentheses
====================================

Recognize :math:`L = \{ w ‚àà \{(,)\}^* | w \text{ is balanced} \}`

State Diagram
--------------

.. graphviz::
   :align: center
   :caption: PDA for Balanced Parentheses
   :name: fig-pda-balanced

   digraph PDA {
      rankdir=LR;
      node [shape = circle, fontsize=12, style=filled, fillcolor="#f8f8f8", color="#7b1113"];

      q0 [label="q‚ÇÄ\n(start)", shape=doublecircle, fillcolor="#fff8f8"];
      q1 [label="q‚ÇÅ"];
      q2 [label="q‚ÇÇ\n(accept)", shape=doublecircle, fillcolor="#f2fff2"];

      q0 -> q1 [label="Œµ, Œµ ‚Üí $"];
      q1 -> q1 [label="( , Œµ ‚Üí ("];
      q1 -> q1 [label=") , ( ‚Üí Œµ"];
      q1 -> q2 [label="Œµ , $ ‚Üí Œµ"];
   }

Stack Evolution
----------------

.. graphviz::
   :align: center
   :caption: Stack Visualization for input "(())"
   :name: fig-stack-trace-balanced

   digraph StackTrace {
      rankdir=LR;
      node [shape=record, fontsize=11, style=filled];
      
      step0 [label="<f0>State: q‚ÇÄ|<f1>Input: (())|<f2>Stack:\n‚ä•", fillcolor="#fff8f8"];
      step1 [label="<f0>State: q‚ÇÅ|<f1>Input: (())|<f2>Stack:\n$\n‚ä•", fillcolor="#e6f7ff"];
      step2 [label="<f0>State: q‚ÇÅ|<f1>Input: ())|<f2>Stack:\n(\n$\n‚ä•", fillcolor="#e6f7ff"];
      step3 [label="<f0>State: q‚ÇÅ|<f1>Input: ))|<f2>Stack:\n(\n(\n$\n‚ä•", fillcolor="#e6f7ff"];
      step4 [label="<f0>State: q‚ÇÅ|<f1>Input: )|<f2>Stack:\n(\n$\n‚ä•", fillcolor="#e6f7ff"];
      step5 [label="<f0>State: q‚ÇÅ|<f1>Input: Œµ|<f2>Stack:\n$\n‚ä•", fillcolor="#e6f7ff"];
      step6 [label="<f0>State: q‚ÇÇ|<f1>Input: Œµ|<f2>Stack:\n‚ä•", fillcolor="#f2fff2"];
      
      step0 -> step1 [label="Œµ,Œµ‚Üí$"];
      step1 -> step2 [label="(,Œµ‚Üí("];
      step2 -> step3 [label="(,Œµ‚Üí("];
      step3 -> step4 [label="),(‚ÜíŒµ"];
      step4 -> step5 [label="),(‚ÜíŒµ"];
      step5 -> step6 [label="Œµ,$‚ÜíŒµ"];
   }

Formal Acceptance Check ‚Äî Instantaneous Description
-----------------------------------------------------

.. admonition:: ID Sequence for "(())" ‚Äî Accepted by Final State
   :class: id-trace

   **Formal Trace:**

   .. math::

      (q_0, \text{(())}, Œµ) \vdash (q_1, \text{(())}, \$)

      \vdash (q_1, \text{())}, (\$)

      \vdash (q_1, \text{)}, ((\$)

      \vdash (q_1, \text{)}, (\$)

      \vdash (q_1, Œµ, \$)

      \vdash (q_2, Œµ, Œµ)

   **Acceptance:** :math:`(q_0, \text{(())}, Œµ) \vdash^* (q_2, Œµ, Œµ)` where :math:`q_2 ‚àà F`
   
   **Result:** ‚úì **ACCEPTED** (both by final state and empty stack)

----

PDA Example 2: Language a‚Åøb‚Åø
=============================

Recognize :math:`L = \{ a^n b^n | n ‚â• 1 \}` (equal a's followed by equal b's).

State Diagram
--------------

.. graphviz::
   :align: center
   :caption: PDA for a‚Åøb‚Åø
   :name: fig-pda-anbn

   digraph PDA_anbn {
      rankdir=LR;
      node [shape = circle, fontsize=12, style=filled, fillcolor="#f8f8f8", color="#7b1113"];

      q0 [label="q‚ÇÄ\n(start)", fillcolor="#fff8f8"];
      q1 [label="q‚ÇÅ\n(push)"];
      q2 [label="q‚ÇÇ\n(pop)"];
      q3 [label="q‚ÇÉ\n(accept)", shape=doublecircle, fillcolor="#f2fff2"];

      q0 -> q1 [label="Œµ, Œµ ‚Üí $"];
      q1 -> q1 [label="a, Œµ ‚Üí A"];
      q1 -> q2 [label="b, A ‚Üí Œµ"];
      q2 -> q2 [label="b, A ‚Üí Œµ"];
      q2 -> q3 [label="Œµ, $ ‚Üí Œµ"];
   }

Stack Evolution
----------------

.. graphviz::
   :align: center
   :caption: Stack Evolution for "aaabbb"
   :name: fig-stack-anbn

   digraph StackTrace_anbn {
      rankdir=LR;
      node [shape=record, fontsize=10, style=filled];
      
      s0 [label="<f0>q‚ÇÄ|<f1>aaabbb|<f2>‚ä•", fillcolor="#fff8f8"];
      s1 [label="<f0>q‚ÇÅ|<f1>aaabbb|<f2>$", fillcolor="#e6f7ff"];
      s2 [label="<f0>q‚ÇÅ|<f1>aabbb|<f2>A\n$", fillcolor="#e6f7ff"];
      s3 [label="<f0>q‚ÇÅ|<f1>abbb|<f2>A\nA\n$", fillcolor="#e6f7ff"];
      s4 [label="<f0>q‚ÇÅ|<f1>bbb|<f2>A\nA\nA\n$", fillcolor="#e6f7ff"];
      s5 [label="<f0>q‚ÇÇ|<f1>bb|<f2>A\nA\n$", fillcolor="#fffbe6"];
      s6 [label="<f0>q‚ÇÇ|<f1>b|<f2>A\n$", fillcolor="#fffbe6"];
      s7 [label="<f0>q‚ÇÇ|<f1>Œµ|<f2>$", fillcolor="#fffbe6"];
      s8 [label="<f0>q‚ÇÉ|<f1>Œµ|<f2>‚ä•", fillcolor="#f2fff2"];
      
      s0 -> s1 [label="Œµ,Œµ‚Üí$"];
      s1 -> s2 [label="a,Œµ‚ÜíA"];
      s2 -> s3 [label="a,Œµ‚ÜíA"];
      s3 -> s4 [label="a,Œµ‚ÜíA"];
      s4 -> s5 [label="b,A‚ÜíŒµ"];
      s5 -> s6 [label="b,A‚ÜíŒµ"];
      s6 -> s7 [label="b,A‚ÜíŒµ"];
      s7 -> s8 [label="Œµ,$‚ÜíŒµ"];
   }

Formal Acceptance Check ‚Äî Instantaneous Description
-----------------------------------------------------

.. admonition:: ID Sequence for "aaabbb" ‚Äî Accepted by Final State
   :class: id-trace

   **Formal Trace:**

   .. math::

      (q_0, \text{aaabbb}, Œµ) \vdash (q_1, \text{aaabbb}, \$)

      \vdash (q_1, \text{aabbb}, A\$)

      \vdash (q_1, \text{abbb}, AA\$)

      \vdash (q_1, \text{bbb}, AAA\$)

      \vdash (q_2, \text{bb}, AA\$)

      \vdash (q_2, \text{b}, A\$)

      \vdash (q_2, Œµ, \$)

      \vdash (q_3, Œµ, Œµ)

   **Acceptance:** :math:`(q_0, \text{aaabbb}, Œµ) \vdash^* (q_3, Œµ, Œµ)` where :math:`q_3 ‚àà F`
   
   **Result:** ‚úì **ACCEPTED**

Rejection Check ‚Äî Instantaneous Description
----------------------------------------------

.. admonition:: ID Sequence for "aabb" ‚Äî REJECTED (shows why)
   :class: quiz

   **Formal Trace (Partial):**

   .. math::

      (q_0, \text{aabb}, Œµ) \vdash (q_1, \text{aabb}, \$)

      \vdash (q_1, \text{abb}, A\$)

      \vdash (q_1, \text{bb}, AA\$)

      \vdash (q_2, \text{b}, A\$)

      \vdash (q_2, Œµ, \$)

      \vdash (q_3, Œµ, Œµ)

   **Failure Reason:** Only 2 a's pushed but 2 b's attempted to pop.
   
   Actually, this **IS accepted** (shows equal matching works).
   
   **Try "aaab":** Stack never empties with symbol left ‚Üí **REJECTED**.

----

PDA Example 3: Palindromes WcW·¥ø
================================

Recognize :math:`L = \{ WcW^R | W ‚àà \{a,b\}^* \}` (palindromes with center marker).

State Diagram
--------------

.. graphviz::
   :align: center
   :caption: PDA for WcW·¥ø
   :name: fig-pda-palindrome

   digraph PDA_palindrome {
      rankdir=LR;
      node [shape = circle, fontsize=11, style=filled, fillcolor="#f8f8f8", color="#7b1113"];

      q0 [label="q‚ÇÄ", fillcolor="#fff8f8"];
      q1 [label="q‚ÇÅ\npush W"];
      q2 [label="q‚ÇÇ\nmatch W·¥ø"];
      q3 [label="q‚ÇÉ", shape=doublecircle, fillcolor="#f2fff2"];

      q0 -> q1 [label="Œµ, Œµ ‚Üí $"];
      q1 -> q1 [label="a, Œµ ‚Üí a\nb, Œµ ‚Üí b"];
      q1 -> q2 [label="c, Œµ ‚Üí Œµ"];
      q2 -> q2 [label="a, a ‚Üí Œµ\nb, b ‚Üí Œµ"];
      q2 -> q3 [label="Œµ, $ ‚Üí Œµ"];
   }

Stack Evolution
----------------

.. graphviz::
   :align: center
   :caption: Stack Evolution for "abcba"
   :name: fig-stack-palindrome

   digraph StackTrace_palindrome {
      rankdir=LR;
      node [shape=record, fontsize=10, style=filled];
      
      p0 [label="<f0>q‚ÇÄ|<f1>abcba|<f2>‚ä•", fillcolor="#fff8f8"];
      p1 [label="<f0>q‚ÇÅ|<f1>abcba|<f2>$", fillcolor="#e6f7ff"];
      p2 [label="<f0>q‚ÇÅ|<f1>bcba|<f2>a\n$", fillcolor="#e6f7ff"];
      p3 [label="<f0>q‚ÇÅ|<f1>cba|<f2>b\na\n$", fillcolor="#e6f7ff"];
      p4 [label="<f0>q‚ÇÇ|<f1>ba|<f2>b\na\n$", fillcolor="#fffbe6"];
      p5 [label="<f0>q‚ÇÇ|<f1>a|<f2>a\n$", fillcolor="#fffbe6"];
      p6 [label="<f0>q‚ÇÇ|<f1>Œµ|<f2>$", fillcolor="#fffbe6"];
      p7 [label="<f0>q‚ÇÉ|<f1>Œµ|<f2>‚ä•", fillcolor="#f2fff2"];
      
      p0 -> p1 [label="Œµ,Œµ‚Üí$"];
      p1 -> p2 [label="a,Œµ‚Üía"];
      p2 -> p3 [label="b,Œµ‚Üíb"];
      p3 -> p4 [label="c,Œµ‚ÜíŒµ"];
      p4 -> p5 [label="b,b‚ÜíŒµ"];
      p5 -> p6 [label="a,a‚ÜíŒµ"];
      p6 -> p7 [label="Œµ,$‚ÜíŒµ"];
   }

Formal Acceptance Check ‚Äî Instantaneous Description
-----------------------------------------------------

.. admonition:: ID Sequence for "abcba" ‚Äî Accepted by Final State
   :class: id-trace

   **Formal Trace:**

   .. math::

      (q_0, \text{abcba}, Œµ) \vdash (q_1, \text{abcba}, \$)

      \vdash (q_1, \text{bcba}, a\$)

      \vdash (q_1, \text{cba}, ba\$)

      \vdash (q_2, \text{ba}, ba\$)

      \vdash (q_2, \text{a}, a\$)

      \vdash (q_2, Œµ, \$)

      \vdash (q_3, Œµ, Œµ)

   **Acceptance:** :math:`(q_0, \text{abcba}, Œµ) \vdash^* (q_3, Œµ, Œµ)` where :math:`q_3 ‚àà F`
   
   **Result:** ‚úì **ACCEPTED** ‚Äî Perfect palindrome match

Rejection Check ‚Äî Instantaneous Description
----------------------------------------------

.. admonition:: ID Sequence for "abcda" ‚Äî REJECTED
   :class: quiz

   **Formal Trace (Partial):**

   .. math::

      (q_0, \text{abcda}, Œµ) \vdash (q_1, \text{abcda}, \$)

      \vdash (q_1, \text{bcda}, a\$)

      \vdash (q_1, \text{cda}, ba\$)

      \vdash (q_2, \text{da}, ba\$)

      \vdash \text{STUCK!}

   **Failure Reason:** At :math:`q_2`, reading input 'd' with 'b' on top of stack.
   No transition: :math:`Œ¥(q_2, d, b)` is undefined.
   
   **Result:** ‚úó **REJECTED** ‚Äî No valid computation path

----

PDA Example 4: Balanced Square Brackets
=========================================

Recognize :math:`L = \{ w ‚àà \{[,]\}^* | w \text{ has balanced brackets} \}`

State Diagram
--------------

.. graphviz::
   :align: center
   :caption: PDA for Balanced Brackets
   :name: fig-pda-brackets

   digraph PDA_brackets {
      rankdir=LR;
      node [shape = circle, fontsize=12, style=filled, fillcolor="#f8f8f8", color="#7b1113"];

      q0 [label="q‚ÇÄ\n(start)", fillcolor="#fff8f8"];
      q1 [label="q‚ÇÅ"];
      q2 [label="q‚ÇÇ\n(accept)", shape=doublecircle, fillcolor="#f2fff2"];

      q0 -> q1 [label="Œµ, Œµ ‚Üí $"];
      q1 -> q1 [label="[ , Œµ ‚Üí ["];
      q1 -> q1 [label="] , [ ‚Üí Œµ"];
      q1 -> q2 [label="Œµ , $ ‚Üí Œµ"];
   }

Formal Acceptance Check ‚Äî Instantaneous Description
-----------------------------------------------------

.. admonition:: ID Sequence for "[[]]" ‚Äî Accepted by Empty Stack
   :class: id-trace

   **Formal Trace:**

   .. math::

      (q_0, [\![\!]\!], Œµ) \vdash (q_1, [\![\!]\!], \$)

      \vdash (q_1, [\!]\!], [\$)

      \vdash (q_1, ]\!], [\![\$)

      \vdash (q_1, ]\!], [\$)

      \vdash (q_1, Œµ, \$)

      \vdash (q_2, Œµ, Œµ)

   **Acceptance Criteria ‚Äî Empty Stack:** :math:`(q_0, [\![\!]\!], Œµ) \vdash^* (q, Œµ, Œµ)` for **any** state :math:`q`
   
   **Result:** ‚úì **ACCEPTED** by empty stack at state :math:`q_1`

Rejection Check ‚Äî Instantaneous Description
----------------------------------------------

.. admonition:: ID Sequence for "[[]][" ‚Äî REJECTED
   :class: quiz

   **Formal Trace:**

   .. math::

      (q_0, [\![\!]\!]\![, Œµ) \vdash (q_1, [\![\!]\!]\![, \$)

      \vdash (q_1, [\!]\!]\![, [\$)

      \vdash (q_1, ]\!]\![, [\![\$)

      \vdash (q_1, ]\![, [\$)

      \vdash (q_1, [\!], \$)

      \vdash (q_1, [\!], [\$)

      \vdash (q_1, ], [\![\$)

      \vdash (q_1, ], [\$)

      \vdash (q_1, Œµ, \$)

      \vdash (q_2, Œµ, Œµ)

   **Result:** ‚úì **ACCEPTED** (actually balanced!)
   
   **Try "[[](]] ":** Stack has leftover [ ‚Üí **REJECTED**

----

Key Insights from ID Traces
============================

.. raw:: html

   <details style="margin-top:1em; background-color:#f9f9f9; border-left:4px solid #7b1113; padding:0.5em 1em; border-radius:8px;">
   <summary style="cursor:pointer; font-weight:600; color:#7b1113;">üéØ Understanding Acceptance Criteria (Click to Expand)</summary>
   <p>
   <strong>By Final State:</strong><br>
   - Input must be fully consumed (:math:`w = Œµ`)<br>
   - Must end in accepting state (:math:`q ‚àà F`)<br>
   - Stack contents don't matter<br><br>
   <strong>By Empty Stack:</strong><br>
   - Input must be fully consumed (:math:`w = Œµ`)<br>
   - Stack must be empty (:math:`Œ± = Œµ`)<br>
   - Final state doesn't matter<br><br>
   <strong>Common Pattern in IDs:</strong><br>
   - Stack grows during "push phases"<br>
   - Stack shrinks during "match/pop phases"<br>
   - Both phases visible in formal trace
   </p>
   </details>

----

Summary
=======

* PDAs = CFGs in power ‚Üí both define CFLs  
* DFAs < PDAs < Turing Machines  
* Stack enables recursion, nesting, and matching  
* **Instantaneous Description** provides formal verification of acceptance  
* **Turnstile notation** :math:`\vdash` makes computation sequences explicit  
* Foundation for parser design and syntax analysis

----
