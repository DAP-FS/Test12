=============================
Pushdown Automata (PDA)
=============================

.. contents::
   :local:
   :depth: 2

----

.. raw:: html

   <style>
     h2, h3 { color: #7B1113; }
     .admonition.hint { background: #E6F7FF; border-left: 6px solid #1890FF; }
     .admonition.note { background: #FFFBE6; border-left: 6px solid #FAAD14; }
     .admonition.exercise { background: #F0F5FF; border-left: 6px solid #2F54EB; }
     .admonition.quiz { background: #FFF1F0; border-left: 6px solid #FF4D4F; }
     .admonition.id-trace { background: #F5F5F5; border-left: 6px solid #722C2C; padding: 0.75em; }
     .transition-box { background: #f0f9ff; border: 2px solid #1890FF; padding: 1em; margin: 1em 0; border-radius: 6px; }
     code.notation { background: #e8e8e8; padding: 0.3em 0.6em; font-family: monospace; font-weight: bold; }
   </style>

----

Introduction
============

A **Pushdown Automaton (PDA)** is the *minimal machine* that can recognize **languages with nested or hierarchical structure** using a stack.  
It is the natural computational counterpart to **Context-Free Grammars (CFGs)** for parsing **balanced patterns and matched constructs**.

A PDA can accept a language **either by final state** or **by empty stack**, and both acceptance modes are *equivalent in power* for context-free languages.

.. hint::

   PDAs extend finite automata with a **stack memory**, giving just enough power to match *opens with closes* (like parentheses or tags) ‚Äî but still simpler than a Turing machine.

----

Why PDA?
=========

* **DFA/NFA fail** on nested patterns because they have only finite memory.
* **PDA succeeds** by using a **stack** ‚Äî push on every open symbol, pop on each matching close, and accept when both input and stack align.

.. note::

   - A PDA adds one unbounded *LIFO* stack to a finite automaton.  
   - This lets it match recursive structures such as parentheses, expressions, or HTML tags.

----

Formal Definition
=================

A **PDA** is a 7-tuple:

.. math::

   M = (Q, Œ£, Œì, Œ¥, q_0, Z_0, F)

where:

- :math:`Q` ‚Äî finite set of states  
- :math:`Œ£` ‚Äî input alphabet  
- :math:`Œì` ‚Äî stack alphabet  
- :math:`Œ¥` ‚Äî transition relation  
- :math:`q_0` ‚Äî start state  
- :math:`Z_0` ‚Äî initial stack symbol  
- :math:`F` ‚Äî set of accepting states

A transition in notation:

.. math::

   Œ¥(q, a, X) ‚Üí (q', Œ≥)

means: *in state q*, reading input symbol *a* (or Œµ), with *X* on top of stack ‚Äî  
**pop X**, and **push Œ≥** (possibly Œµ) while moving to state *q'*.

----

Transition Notation Explained
=============================

The format :math:`(q, a, X) ‚Üí (q', Œ≥)` has three parts:

.. raw:: html

   <div class="transition-box">
   <strong>Format:</strong> (current_state, input_symbol, stack_top) ‚Üí (next_state, new_stack_symbols)
   <br><br>
   <strong>Example:</strong> (q‚ÇÅ, a, Z) ‚Üí (q‚ÇÅ, AZ)<br>
   &nbsp;&nbsp;‚Üí In state q‚ÇÅ, reading 'a', with Z on top of stack<br>
   &nbsp;&nbsp;‚Üí Move to q‚ÇÅ, pop Z, push A then Z (net effect: push A)
   <br><br>
   <strong>Note:</strong> Œ≥ can be:<br>
   &nbsp;&nbsp;‚Ä¢ Single symbol (q, a, X) ‚Üí (q', Y)  [pop X, push Y]<br>
   &nbsp;&nbsp;‚Ä¢ Multiple symbols (q, a, X) ‚Üí (q', YZ)  [pop X, push Y then Z]<br>
   &nbsp;&nbsp;‚Ä¢ Empty (q, a, X) ‚Üí (q', Œµ)  [pop X, push nothing]
   </div>

----

Acceptance Modes
================

* **Acceptance by Final State** ‚Äî consume entire input and end in any state in *F*; stack contents may remain.  
* **Acceptance by Empty Stack** ‚Äî consume input and empty the stack; final state ignored.

.. hint::

   Both modes recognize **exactly the same class** of languages: *Context-Free Languages (CFLs)*.

----

PDA Example 1: Balanced Parentheses "()"
==========================================

Recognize :math:`L = \{ w ‚àà \{(,)\}^* | w \text{ is balanced} \}`

**Formal Definition:**

.. math::

   M = (\{q_0, q_1, q_2\}, \{(, )\}, \{(, \$\}, Œ¥, q_0, \$, \{q_2\})

**Transition Rules** ‚Äî Format: :math:`(q, a, X) ‚Üí (q', Œ≥)`

.. raw:: html

   <div class="transition-box">
   <p><strong>Setup Transition:</strong></p>
   <code class="notation">(q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $)</code><br>
   Initialize stack with bottom marker ($)
   <br><br>
   <p><strong>Push Transitions:</strong></p>
   <code class="notation">(q‚ÇÅ, '(', Œµ) ‚Üí (q‚ÇÅ, '(')</code><br>
   Reading '(': push '(' onto stack
   <br><br>
   <p><strong>Pop Transitions:</strong></p>
   <code class="notation">(q‚ÇÅ, ')', '(') ‚Üí (q‚ÇÅ, Œµ)</code><br>
   Reading ')' with '(' on top: pop it (remove from stack)
   <br><br>
   <p><strong>Accept Transition:</strong></p>
   <code class="notation">(q‚ÇÅ, Œµ, $) ‚Üí (q‚ÇÇ, Œµ)</code><br>
   When only $ remains, move to final state (empty stack)
   </div>

Acceptance Check ‚Äî "(())"
---------------------------

.. admonition:: String Trace for "(())" ‚Äî ACCEPTED
   :class: id-trace

   **Input:** (())  
   **Stack bottom:** $

   | Step | State | Input | Stack | Transition Applied |
   |------|-------|-------|-------|-------------------|
   | 0 | q‚ÇÄ | (()) | Œµ | ‚Äî |
   | 1 | q‚ÇÅ | (()) | $ | (q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $) |
   | 2 | q‚ÇÅ | ()) | ($ | (q‚ÇÅ, '(', Œµ) ‚Üí (q‚ÇÅ, '(') |
   | 3 | q‚ÇÅ | )) | (($ | (q‚ÇÅ, '(', Œµ) ‚Üí (q‚ÇÅ, '(') |
   | 4 | q‚ÇÅ | ) | ($ | (q‚ÇÅ, ')', '(') ‚Üí (q‚ÇÅ, Œµ) |
   | 5 | q‚ÇÅ | Œµ | $ | (q‚ÇÅ, ')', '(') ‚Üí (q‚ÇÅ, Œµ) |
   | 6 | q‚ÇÇ | Œµ | Œµ | (q‚ÇÅ, Œµ, $) ‚Üí (q‚ÇÇ, Œµ) |

   **Result:** ‚úì **ACCEPTED** ‚Äî Input consumed, stack empty, final state q‚ÇÇ reached

Rejection Check ‚Äî "(()"
-------------------------

.. admonition:: String Trace for "(()" ‚Äî REJECTED
   :class: quiz

   **Input:** (()  
   **Stack bottom:** $

   | Step | State | Input | Stack | Transition Applied |
   |------|-------|-------|-------|-------------------|
   | 0 | q‚ÇÄ | (() | Œµ | ‚Äî |
   | 1 | q‚ÇÅ | (() | $ | (q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $) |
   | 2 | q‚ÇÅ | ()) | ($ | (q‚ÇÅ, '(', Œµ) ‚Üí (q‚ÇÅ, '(') |
   | 3 | q‚ÇÅ | )) | (($ | (q‚ÇÅ, '(', Œµ) ‚Üí (q‚ÇÅ, '(') |
   | 4 | q‚ÇÅ | ) | ($ | (q‚ÇÅ, ')', '(') ‚Üí (q‚ÇÅ, Œµ) |
   | 5 | q‚ÇÅ | Œµ | ($ | **STUCK** ‚Äî No transition for (q‚ÇÅ, Œµ, '(') |

   **Result:** ‚úó **REJECTED** ‚Äî Input ends but stack still has '(' (unmatched open)

State Diagram
--------------

.. graphviz::
   :align: center
   :caption: PDA for Balanced Parentheses
   :name: fig-pda-balanced

   digraph PDA {
      rankdir=LR;
      node [shape = circle, fontsize=12, style=filled, fillcolor="#f8f8f8", color="#7b1113"];

      q0 [label="q‚ÇÄ\n(start)", shape=doublecircle, fillcolor="#fff8f8"];
      q1 [label="q‚ÇÅ"];
      q2 [label="q‚ÇÇ\n(accept)", shape=doublecircle, fillcolor="#f2fff2"];

      q0 -> q1 [label="Œµ, Œµ ‚Üí $"];
      q1 -> q1 [label="(, Œµ ‚Üí ("];
      q1 -> q1 [label="), ( ‚Üí Œµ"];
      q1 -> q2 [label="Œµ, $ ‚Üí Œµ"];
   }

----

PDA Example 2: Language a‚Åøb‚Åø
=============================

Recognize :math:`L = \{ a^n b^n | n ‚â• 1 \}` (equal a's followed by equal b's).

**Formal Definition:**

.. math::

   M = (\{q_0, q_1, q_2, q_3\}, \{a, b\}, \{A, \$\}, Œ¥, q_0, \$, \{q_3\})

**Transition Rules** ‚Äî Format: :math:`(q, a, X) ‚Üí (q', Œ≥)`

.. raw:: html

   <div class="transition-box">
   <p><strong>Setup Transition:</strong></p>
   <code class="notation">(q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $)</code><br>
   Initialize stack with bottom marker ($)
   <br><br>
   <p><strong>Push Phase ‚Äî Read a's, Push A's:</strong></p>
   <code class="notation">(q‚ÇÅ, a, Œµ) ‚Üí (q‚ÇÅ, A)</code><br>
   Reading 'a' at stack bottom: push A
   <br>
   <code class="notation">(q‚ÇÅ, a, A) ‚Üí (q‚ÇÅ, AA)</code><br>
   Reading 'a' with A on top: push another A
   <br><br>
   <p><strong>Switch Phase ‚Äî First b arrives, move to pop:</strong></p>
   <code class="notation">(q‚ÇÅ, b, A) ‚Üí (q‚ÇÇ, Œµ)</code><br>
   Reading first 'b' with A on top: pop A, move to pop state
   <br><br>
   <p><strong>Pop Phase ‚Äî Read b's, Pop A's:</strong></p>
   <code class="notation">(q‚ÇÇ, b, A) ‚Üí (q‚ÇÇ, Œµ)</code><br>
   Reading 'b' with A on top: pop A
   <br><br>
   <p><strong>Accept Transition:</strong></p>
   <code class="notation">(q‚ÇÇ, Œµ, $) ‚Üí (q‚ÇÉ, Œµ)</code><br>
   When only $ remains: accept (stack empty)
   </div>

Acceptance Check ‚Äî "aaabbb"
-----------------------------

.. admonition:: String Trace for "aaabbb" ‚Äî ACCEPTED
   :class: id-trace

   **Input:** aaabbb  
   **Stack bottom:** $

   | Step | State | Input | Stack | Transition Applied |
   |------|-------|-------|-------|-------------------|
   | 0 | q‚ÇÄ | aaabbb | Œµ | ‚Äî |
   | 1 | q‚ÇÅ | aaabbb | $ | (q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $) |
   | 2 | q‚ÇÅ | aabbb | A$ | (q‚ÇÅ, a, Œµ) ‚Üí (q‚ÇÅ, A) |
   | 3 | q‚ÇÅ | abbb | AA$ | (q‚ÇÅ, a, A) ‚Üí (q‚ÇÅ, AA) |
   | 4 | q‚ÇÅ | bbb | AAA$ | (q‚ÇÅ, a, A) ‚Üí (q‚ÇÅ, AA) |
   | 5 | q‚ÇÇ | bb | AA$ | (q‚ÇÅ, b, A) ‚Üí (q‚ÇÇ, Œµ) **[Switch to pop]** |
   | 6 | q‚ÇÇ | b | A$ | (q‚ÇÇ, b, A) ‚Üí (q‚ÇÇ, Œµ) |
   | 7 | q‚ÇÇ | Œµ | $ | (q‚ÇÇ, b, A) ‚Üí (q‚ÇÇ, Œµ) |
   | 8 | q‚ÇÉ | Œµ | Œµ | (q‚ÇÇ, Œµ, $) ‚Üí (q‚ÇÉ, Œµ) |

   **Result:** ‚úì **ACCEPTED** ‚Äî Perfect matching: 3 a's pushed, 3 b's popped

Rejection Check ‚Äî "aabbb"
---------------------------

.. admonition:: String Trace for "aabbb" ‚Äî REJECTED
   :class: quiz

   **Input:** aabbb  
   **Stack bottom:** $

   | Step | State | Input | Stack | Transition Applied |
   |------|-------|-------|-------|-------------------|
   | 0 | q‚ÇÄ | aabbb | Œµ | ‚Äî |
   | 1 | q‚ÇÅ | aabbb | $ | (q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $) |
   | 2 | q‚ÇÅ | abbb | A$ | (q‚ÇÅ, a, Œµ) ‚Üí (q‚ÇÅ, A) |
   | 3 | q‚ÇÅ | bbb | AA$ | (q‚ÇÅ, a, A) ‚Üí (q‚ÇÅ, AA) |
   | 4 | q‚ÇÇ | bb | A$ | (q‚ÇÅ, b, A) ‚Üí (q‚ÇÇ, Œµ) **[Switch to pop]** |
   | 5 | q‚ÇÇ | b | $ | (q‚ÇÇ, b, A) ‚Üí (q‚ÇÇ, Œµ) |
   | 6 | q‚ÇÇ | Œµ | $ | **STUCK** ‚Äî No transition for (q‚ÇÇ, b, $) |

   **Result:** ‚úó **REJECTED** ‚Äî 2 a's but 3 b's (mismatch)

State Diagram
--------------

.. graphviz::
   :align: center
   :caption: PDA for a‚Åøb‚Åø
   :name: fig-pda-anbn

   digraph PDA_anbn {
      rankdir=LR;
      node [shape = circle, fontsize=12, style=filled, fillcolor="#f8f8f8", color="#7b1113"];

      q0 [label="q‚ÇÄ\n(start)", fillcolor="#fff8f8"];
      q1 [label="q‚ÇÅ\n(push)"];
      q2 [label="q‚ÇÇ\n(pop)"];
      q3 [label="q‚ÇÉ\n(accept)", shape=doublecircle, fillcolor="#f2fff2"];

      q0 -> q1 [label="Œµ, Œµ ‚Üí $"];
      q1 -> q1 [label="a, Œµ ‚Üí A\na, A ‚Üí AA"];
      q1 -> q2 [label="b, A ‚Üí Œµ"];
      q2 -> q2 [label="b, A ‚Üí Œµ"];
      q2 -> q3 [label="Œµ, $ ‚Üí Œµ"];
   }

----

PDA Example 3: Palindromes WcW·¥ø
================================

Recognize :math:`L = \{ WcW^R | W ‚àà \{a,b\}^* \}` (palindromes with center marker 'c').

**Formal Definition:**

.. math::

   M = (\{q_0, q_1, q_2, q_3\}, \{a, b, c\}, \{a, b, \$\}, Œ¥, q_0, \$, \{q_3\})

**Transition Rules** ‚Äî Format: :math:`(q, a, X) ‚Üí (q', Œ≥)`

.. raw:: html

   <div class="transition-box">
   <p><strong>Setup Transition:</strong></p>
   <code class="notation">(q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $)</code><br>
   Initialize stack with bottom marker ($)
   <br><br>
   <p><strong>Push Phase ‚Äî Read W, Push symbols:</strong></p>
   <code class="notation">(q‚ÇÅ, a, Œµ) ‚Üí (q‚ÇÅ, a)</code><br>
   Reading 'a' with Œµ (empty stack): push 'a'
   <br>
   <code class="notation">(q‚ÇÅ, a, a) ‚Üí (q‚ÇÅ, aa)</code><br>
   Reading 'a' with 'a' on top: push another 'a'
   <br>
   <code class="notation">(q‚ÇÅ, a, b) ‚Üí (q‚ÇÅ, ab)</code><br>
   Reading 'a' with 'b' on top: push 'a' (stacked on top)
   <br>
   <code class="notation">(q‚ÇÅ, b, Œµ) ‚Üí (q‚ÇÅ, b)</code><br>
   Reading 'b' with Œµ: push 'b'
   <br>
   <code class="notation">(q‚ÇÅ, b, a) ‚Üí (q‚ÇÅ, ba)</code><br>
   Reading 'b' with 'a' on top: push 'b' on top
   <br>
   <code class="notation">(q‚ÇÅ, b, b) ‚Üí (q‚ÇÅ, bb)</code><br>
   Reading 'b' with 'b' on top: push another 'b'
   <br><br>
   <p><strong>Pivot ‚Äî Read center marker 'c':</strong></p>
   <code class="notation">(q‚ÇÅ, c, a) ‚Üí (q‚ÇÇ, a)</code><br>
   Reading 'c' with any letter on top: move to match state (no stack change)
   <br>
   <code class="notation">(q‚ÇÅ, c, b) ‚Üí (q‚ÇÇ, b)</code><br>
   Reading 'c' with any letter on top: move to match state
   <br><br>
   <p><strong>Match Phase ‚Äî Read W·¥ø, Pop matching symbols:</strong></p>
   <code class="notation">(q‚ÇÇ, a, a) ‚Üí (q‚ÇÇ, Œµ)</code><br>
   Reading 'a' with 'a' on top: pop 'a'
   <br>
   <code class="notation">(q‚ÇÇ, b, b) ‚Üí (q‚ÇÇ, Œµ)</code><br>
   Reading 'b' with 'b' on top: pop 'b'
   <br><br>
   <p><strong>Accept Transition:</strong></p>
   <code class="notation">(q‚ÇÇ, Œµ, $) ‚Üí (q‚ÇÉ, Œµ)</code><br>
   When only $ remains: accept
   </div>

Acceptance Check ‚Äî "abcba"
-----------------------------

.. admonition:: String Trace for "abcba" ‚Äî ACCEPTED
   :class: id-trace

   **Input:** abcba  
   **Stack bottom:** $

   | Step | State | Input | Stack | Transition Applied |
   |------|-------|-------|-------|-------------------|
   | 0 | q‚ÇÄ | abcba | Œµ | ‚Äî |
   | 1 | q‚ÇÅ | abcba | $ | (q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $) |
   | 2 | q‚ÇÅ | bcba | a$ | (q‚ÇÅ, a, Œµ) ‚Üí (q‚ÇÅ, a) |
   | 3 | q‚ÇÅ | cba | ba$ | (q‚ÇÅ, b, a) ‚Üí (q‚ÇÅ, ba) |
   | 4 | q‚ÇÇ | ba | ba$ | (q‚ÇÅ, c, b) ‚Üí (q‚ÇÇ, b) **[Pivot: switch to match]** |
   | 5 | q‚ÇÇ | a | a$ | (q‚ÇÇ, b, b) ‚Üí (q‚ÇÇ, Œµ) |
   | 6 | q‚ÇÇ | Œµ | $ | (q‚ÇÇ, a, a) ‚Üí (q‚ÇÇ, Œµ) |
   | 7 | q‚ÇÉ | Œµ | Œµ | (q‚ÇÇ, Œµ, $) ‚Üí (q‚ÇÉ, Œµ) |

   **Result:** ‚úì **ACCEPTED** ‚Äî Palindrome verified: W="ab" matched with W·¥ø="ba"

Rejection Check ‚Äî "abcda"
---------------------------

.. admonition:: String Trace for "abcda" ‚Äî REJECTED
   :class: quiz

   **Input:** abcda  
   **Stack bottom:** $

   | Step | State | Input | Stack | Transition Applied |
   |------|-------|-------|-------|-------------------|
   | 0 | q‚ÇÄ | abcda | Œµ | ‚Äî |
   | 1 | q‚ÇÅ | abcda | $ | (q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $) |
   | 2 | q‚ÇÅ | bcda | a$ | (q‚ÇÅ, a, Œµ) ‚Üí (q‚ÇÅ, a) |
   | 3 | q‚ÇÅ | cda | ba$ | (q‚ÇÅ, b, a) ‚Üí (q‚ÇÅ, ba) |
   | 4 | q‚ÇÇ | da | ba$ | (q‚ÇÅ, c, b) ‚Üí (q‚ÇÇ, b) **[Pivot]** |
   | 5 | q‚ÇÇ | a | ba$ | **STUCK** ‚Äî No transition for (q‚ÇÇ, d, b) |

   **Result:** ‚úó **REJECTED** ‚Äî Symbol 'd' not in alphabet {a,b,c}; mismatch if it were

State Diagram
--------------

.. graphviz::
   :align: center
   :caption: PDA for Palindromes WcW·¥ø
   :name: fig-pda-palindrome

   digraph PDA_palindrome {
      rankdir=LR;
      node [shape = circle, fontsize=11, style=filled, fillcolor="#f8f8f8", color="#7b1113"];

      q0 [label="q‚ÇÄ\n(start)", fillcolor="#fff8f8"];
      q1 [label="q‚ÇÅ\npush W"];
      q2 [label="q‚ÇÇ\nmatch W·¥ø"];
      q3 [label="q‚ÇÉ\n(accept)", shape=doublecircle, fillcolor="#f2fff2"];

      q0 -> q1 [label="Œµ, Œµ ‚Üí $"];
      q1 -> q1 [label="a, Œµ ‚Üí a\na, a ‚Üí aa\na, b ‚Üí ab"];
      q1 -> q1 [label="b, Œµ ‚Üí b\nb, a ‚Üí ba\nb, b ‚Üí bb"];
      q1 -> q2 [label="c, a ‚Üí a\nc, b ‚Üí b"];
      q2 -> q2 [label="a, a ‚Üí Œµ\nb, b ‚Üí Œµ"];
      q2 -> q3 [label="Œµ, $ ‚Üí Œµ"];
   }

----

PDA Example 4: Equal Count a‚Åøb‚Åø (Any Order)
=============================================

Recognize :math:`L = \{ w ‚àà \{a,b\}^* | \#_a(w) = \#_b(w) \}` (equal a's and b's in any order).

**Formal Definition:**

.. math::

   M = (\{q_0, q_1, q_2\}, \{a, b\}, \{A, B, \$\}, Œ¥, q_0, \$, \{q_2\})

**Strategy:** 
- Push A when 'a' exceeds 'b'
- Push B when 'b' exceeds 'a'
- Pop when opposite symbol arrives (cancels out)
- Accept when stack returns to $ only

**Transition Rules** ‚Äî Format: :math:`(q, a, X) ‚Üí (q', Œ≥)`

.. raw:: html

   <div class="transition-box">
   <p><strong>Setup Transition:</strong></p>
   <code class="notation">(q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $)</code><br>
   Initialize stack with bottom marker ($)
   <br><br>
   <p><strong>Read 'a' ‚Äî Push A or Pop B:</strong></p>
   <code class="notation">(q‚ÇÅ, a, $) ‚Üí (q‚ÇÅ, A$)</code><br>
   First symbol 'a' with $ bottom: push A
   <br>
   <code class="notation">(q‚ÇÅ, a, A) ‚Üí (q‚ÇÅ, AA)</code><br>
   'a' with A on top: push another A (increase a-count)
   <br>
   <code class="notation">(q‚ÇÅ, a, B) ‚Üí (q‚ÇÅ, Œµ)</code><br>
   'a' with B on top: pop B (cancel b with a)
   <br><br>
   <p><strong>Read 'b' ‚Äî Push B or Pop A:</strong></p>
   <code class="notation">(q‚ÇÅ, b, $) ‚Üí (q‚ÇÅ, B$)</code><br>
   First symbol 'b' with $ bottom: push B
   <br>
   <code class="notation">(q‚ÇÅ, b, B) ‚Üí (q‚ÇÅ, BB)</code><br>
   'b' with B on top: push another B (increase b-count)
   <br>
   <code class="notation">(q‚ÇÅ, b, A) ‚Üí (q‚ÇÅ, Œµ)</code><br>
   'b' with A on top: pop A (cancel a with b)
   <br><br>
   <p><strong>Accept Transition:</strong></p>
   <code class="notation">(q‚ÇÅ, Œµ, $) ‚Üí (q‚ÇÇ, Œµ)</code><br>
   When only $ remains: accept (equal counts)
   </div>

Acceptance Check ‚Äî "aabb"
---------------------------

.. admonition:: String Trace for "aabb" ‚Äî ACCEPTED
   :class: id-trace

   **Input:** aabb  
   **Stack bottom:** $

   | Step | State | Input | Stack | Transition Applied |
   |------|-------|-------|-------|-------------------|
   | 0 | q‚ÇÄ | aabb | Œµ | ‚Äî |
   | 1 | q‚ÇÅ | aabb | $ | (q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $) |
   | 2 | q‚ÇÅ | abb | A$ | (q‚ÇÅ, a, $) ‚Üí (q‚ÇÅ, A$) |
   | 3 | q‚ÇÅ | bb | AA$ | (q‚ÇÅ, a, A) ‚Üí (q‚ÇÅ, AA) |
   | 4 | q‚ÇÅ | b | B$ | (q‚ÇÅ, b, A) ‚Üí (q‚ÇÅ, Œµ) **[Pop A, cancel]** |
   | 5 | q‚ÇÅ | Œµ | $ | (q‚ÇÅ, b, A) ‚Üí (q‚ÇÅ, Œµ) **[Pop A, cancel]** |
   | 6 | q‚ÇÇ | Œµ | Œµ | (q‚ÇÅ, Œµ, $) ‚Üí (q‚ÇÇ, Œµ) |

   **Result:** ‚úì **ACCEPTED** ‚Äî 2 a's and 2 b's cancel perfectly

Acceptance Check ‚Äî "abab"
---------------------------

.. admonition:: String Trace for "abab" ‚Äî ACCEPTED
   :class: id-trace

   **Input:** abab  
   **Stack bottom:** $

   | Step | State | Input | Stack | Transition Applied |
   |------|-------|-------|-------|-------------------|
   | 0 | q‚ÇÄ | abab | Œµ | ‚Äî |
   | 1 | q‚ÇÅ | abab | $ | (q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $) |
   | 2 | q‚ÇÅ | bab | A$ | (q‚ÇÅ, a, $) ‚Üí (q‚ÇÅ, A$) |
   | 3 | q‚ÇÅ | ab | $ | (q‚ÇÅ, b, A) ‚Üí (q‚ÇÅ, Œµ) **[Pop A, cancel]** |
   | 4 | q‚ÇÅ | b | A$ | (q‚ÇÅ, a, $) ‚Üí (q‚ÇÅ, A$) |
   | 5 | q‚ÇÅ | Œµ | $ | (q‚ÇÅ, b, A) ‚Üí (q‚ÇÅ, Œµ) **[Pop A, cancel]** |
   | 6 | q‚ÇÇ | Œµ | Œµ | (q‚ÇÅ, Œµ, $) ‚Üí (q‚ÇÇ, Œµ) |

   **Result:** ‚úì **ACCEPTED** ‚Äî Interleaved a's and b's, equal counts

Rejection Check ‚Äî "aaab"
--------------------------

.. admonition:: String Trace for "aaab" ‚Äî REJECTED
   :class: quiz

   **Input:** aaab  
   **Stack bottom:** $

   | Step | State | Input | Stack | Transition Applied |
   |------|-------|-------|-------|-------------------|
   | 0 | q‚ÇÄ | aaab | Œµ | ‚Äî |
   | 1 | q‚ÇÅ | aaab | $ | (q‚ÇÄ, Œµ, Œµ) ‚Üí (q‚ÇÅ, $) |
   | 2 | q‚ÇÅ | aab | A$ | (q‚ÇÅ, a, $) ‚Üí (q‚ÇÅ, A$) |
   | 3 | q‚ÇÅ | ab | AA$ | (q‚ÇÅ, a, A) ‚Üí (q‚ÇÅ, AA) |
   | 4 | q‚ÇÅ | b | AAA$ | (q‚ÇÅ, a, A) ‚Üí (q‚ÇÅ, AA) |
   | 5 | q‚ÇÅ | Œµ | AA$ | (q‚ÇÅ, b, A) ‚Üí (q‚ÇÅ, Œµ) **[Pop A]** |
   | 6 | q‚ÇÅ | Œµ | AA$ | **STUCK** ‚Äî Input consumed but stack ‚â† $ |

   **Result:** ‚úó **REJECTED** ‚Äî 3 a's but only 1 b (unequal)

State Diagram
--------------

.. graphviz::
   :align: center
   :caption: PDA for Equal a's and b's (any order)
   :name: fig-pda-equal

   digraph PDA_equal {
      rankdir=LR;
      node [shape = circle, fontsize=11, style=filled, fillcolor="#f8f8f8", color="#7b1113"];

      q0 [label="q‚ÇÄ\n(start)", fillcolor="#fff8f8"];
      q1 [label="q‚ÇÅ\nbalance"];
      q2 [label="q‚ÇÇ\n(accept)", shape=doublecircle, fillcolor="#f2fff2"];

      q0 -> q1 [label="Œµ, Œµ ‚Üí $"];
      
      q1 -> q1 [label="a, $ ‚Üí A$\na, A ‚Üí AA\na, B ‚Üí Œµ"];
      q1 -> q1 [label="b, $ ‚Üí B$\nb, B ‚Üí BB\nb, A ‚Üí Œµ"];
      
      q1 -> q2 [label="Œµ, $ ‚Üí Œµ"];
   }

----

Summary Table ‚Äî Comparing All Examples
=======================================

+------------------------+-------------------------+-------------------+-------------------+
| **Language**           | **Form**                | **Stack Behavior**| **Acceptance**    |
+========================+=========================+===================+===================+
| Balanced ()            | :math:`()*`             | Push (, pop )     | Final state       |
+------------------------+-------------------------+-------------------+-------------------+
| :math:`a^nb^n`         | Equal a's then b's      | Push n A's, pop   | Final state       |
+------------------------+-------------------------+-------------------+-------------------+
| :math:`WcW^R`          | Palindrome + center     | Push W, pop W·¥ø    | Final state       |
+------------------------+-------------------------+-------------------+-------------------+
| Equal :math:`a^*b^*`   | Any interleaved order   | Cancellation      | Final state       |
+------------------------+-------------------------+-------------------+-------------------+

----

Key Principles for Reading Transitions
========================================

.. raw:: html

   <details style="margin-top:1em; background-color:#f9f9f9; border-left:4px solid #7b1113; padding:0.5em 1em; border-radius:8px;">
   <summary style="cursor:pointer; font-weight:600; color:#7b1113;">üéØ How to Understand (q, a, X) ‚Üí (q', Œ≥) (Click to Expand)</summary>
   <p>
   <strong>Component 1: (q, a, X)</strong><br>
   ‚Ä¢ <code>q</code> = current state<br>
   ‚Ä¢ <code>a</code> = input symbol being read (or Œµ for no input consumed)<br>
   ‚Ä¢ <code>X</code> = stack top symbol being popped<br><br>
   
   <strong>Component 2: (q', Œ≥)</strong><br>
   ‚Ä¢ <code>q'</code> = next state to move to<br>
   ‚Ä¢ <code>Œ≥</code> = string to push (can be empty Œµ, single symbol, or multiple)<br><br>
   
   <strong>Order of Stack Operations:</strong><br>
   1. POP: Remove X from stack top<br>
   2. PUSH: Add symbols in Œ≥ left-to-right (leftmost goes first)<br><br>
   
   <strong>Examples:</strong><br>
   ‚Ä¢ <code>(q, a, X) ‚Üí (q, Œµ)</code> = consume 'a', pop X, push nothing<br>
   ‚Ä¢ <code>(q, a, X) ‚Üí (q, YZ)</code> = consume 'a', pop X, push Y then Z (Y on top)<br>
   ‚Ä¢ <code>(q, Œµ, X) ‚Üí (q, Œµ)</code> = no input, pop X, push nothing (spontaneous move)
   </p>
   </details>

----

Summary
=======

* **Transition notation** :math:`(q, a, X) ‚Üí (q', Œ≥)` specifies exact stack operations  
* **Push phase** accumulates symbols (stack grows)  
* **Pop phase** matches and removes symbols (stack shrinks)  
* **Cancellation** allows balancing in any order  
* **Formal traces** show step-by-step computation with stacks visible  
* Foundation for parser design and syntax analysis

----
